3 patches for repository http://gerris.dalembert.upmc.fr/darcs/gerris-stable:sphericity_distribution

Thu Aug  1 17:10:58 IST 2013  mohitiitroorkee@gmail.com
  * particulate_code

Sat Aug 10 18:14:05 IST 2013  mohitiitroorkee@gmail.com
  * particualte_alpha: calculating the maximum distance of interface from the centroid and diving by radius of equivalent sphere to get alpha

Tue Aug 13 17:01:12 IST 2013  mohitiitroorkee@gmail.com
  * sphericity_distribution


New patches:

[particulate_code
mohitiitroorkee@gmail.com**20130801114058
 Ignore-this: 715b38fab889654b35b9992937544870
] hunk ./modules/bubbles.c 38
   gdouble rliq;
   
   /*< public >*/
-  gdouble velR, p0, R0, vol_liq;
+  gdouble velR, p0, R0, vol_liq, dpotdt;
 };
 
 #define GFS_BUBBLE(obj)            GTS_OBJECT_CAST (obj, GfsBubble, gfs_bubble_class ())
hunk ./modules/bubbles.c 54
   GfsBubble * bubble;
 } RPData;
 
-static gdouble p_state_ec (GfsBubble * bubble, gdouble rb)
-{
-  return bubble->p0*pow (bubble->R0/rb, 3.*1.4);
+gdouble static p_state_ec (GfsBubble * bubble, gdouble rb) {
+    /* check negative radius: what to do in this case? */
+    if (rb <= 0 ) {
+      g_warning ("Negative volume for bubbles, reseting values");
+      rb = 1.e-4*bubble->R0;
+    }
+
+    return bubble->p0*pow (bubble->R0/rb, 3.*1.4);
 }
 
 static int func (double t, const double y[], double f[], void * params)
hunk ./modules/bubbles.c 76
 
 /* jacobian matrix */
 int static jac (double t, const double y[], double *dfdy, 
-		double dfdt[], void *params)
+    double dfdt[], void *params)
 {
   RPData * rp = (RPData *) params;
   gdouble pbubble = p_state_ec (rp->bubble, y[0]);
hunk ./modules/bubbles.c 114
     FttVector pos = p->pos;
     gfs_simulation_map (sim, &pos);
 
-    gdouble point_pres = gfs_interpolate (cell, p->pos, liqpres);
+    gdouble point_pres = bubble->dpotdt;
 
     RPData rp = { point_pres, liq_rho, bubble };
 
hunk ./modules/bubbles.c 146
     bubble->velR = y[1];
     particulate->volume = 4./3.*M_PI*y[0]*y[0]*y[0];
 
+    /* trick to impose the pressure with/without interactions. Improve?? */
+    bubble->dpotdt = gfs_interpolate (cell, p->pos, liqpres);
+
     return TRUE;
   }
   return FALSE;
hunk ./modules/bubbles.c 166
   gdouble L = gfs_object_simulation (*o)->physical_params.L;
     
   p->vol_liq = 0;
+  p->dpotdt  = 101300.;
   p->R0 = pow (part->volume*3./(4.*M_PI), 1./3.);
 
   if (fp->type != GTS_INT && fp->type != GTS_FLOAT) {
hunk ./modules/bubbles.c 256
 /** \beginobject{GfsBubbleFraction} */
 /* do it more general? */
 
-static void distance_normalization (FttVector * pos1, GfsParticulate * p)
-{
-  gdouble rb = pow (3.*p->volume/(4.*M_PI), 1./3.);
-  FttVector * pos2 = &(GFS_PARTICLE (p)->pos);
-  pos1->x = (pos1->x - pos2->x)/rb;
-  pos1->y = (pos1->y - pos2->y)/rb;
-  pos1->z = 0.;
-#if !FTT_2D
-  pos1->z = (pos1->z - pos2->z)/rb;
-#endif
-}
-
 static void voidfraction_from_bubbles (FttCell * cell, BubbleData * p)
 {
   FttVector pos;
hunk ./modules/bubbles.c 292
   radeq = size*sqrt(3.);
 #endif /* 3D */
 
+
   if (ftt_vector_distance (&pos, p->pos) - radeq <= p->distance) 
     return TRUE;
hunk ./modules/bubbles.c 295
-    
+
   /* Check also if the bubble is inside the cell*/
   if (p->pos->x > pos.x + size || p->pos->x < pos.x - size ||
       p->pos->y > pos.y + size || p->pos->y < pos.y - size 
hunk ./modules/bubbles.c 302
 #if !FTT_2D
       || p->pos->z > pos.z + size || p->pos->z < pos.z - size 
 #endif
-      )
+     )
     return FALSE;
 
   return TRUE;
hunk ./modules/bubbles.c 309
 }
 
 static gboolean bubble_fraction_event (GfsEvent * event, 
-				       GfsSimulation * sim)
+    GfsSimulation * sim)
 {
   if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_particulate_field_class ())->parent_class)->event)
       (event, sim)) {
hunk ./modules/bubbles.c 317
     GfsVariable * v = GFS_VARIABLE (event);
     GfsParticulateField * pfield = GFS_PARTICULATE_FIELD (v);
     GfsBubbleFraction * bf = GFS_BUBBLE_FRACTION (event);
-    
+
     /* Reset variable */
     gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
hunk ./modules/bubbles.c 320
-			      (FttCellTraverseFunc) gfs_cell_reset, v);
+        (FttCellTraverseFunc) gfs_cell_reset, v);
     /* Loop over the list of particles in the selected object */
     GSList * i = GFS_EVENT_LIST (pfield->plist)->list->items;
     while (i) {
hunk ./modules/bubbles.c 330
       BubbleData p = { 0, bubble, v, bf };
       CondData cd = { &GFS_PARTICLE (i->data)->pos, bubble->rliq };
       gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
-                                          (FttCellTraverseFunc) kernel_volume, &p,
-                                          cond_bubble, &cd);
+          (FttCellTraverseFunc) kernel_volume, &p,
+          cond_bubble, &cd);          
       gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
hunk ./modules/bubbles.c 333
-                                          (FttCellTraverseFunc) pfield->voidfraction_func, &p,
-                                          cond_bubble, &cd);
+          (FttCellTraverseFunc) pfield->voidfraction_func, &p,
+          cond_bubble, &cd);          
       i = i->next;
     }
     return TRUE;
hunk ./modules/bubbles.c 355
   if (fp->type == GTS_ERROR)
     return;
 
-  GfsBubbleFraction * b = GFS_BUBBLE_FRACTION (*o);
+  GfsBubbleFraction * b = GFS_BUBBLE_FRACTION(*o);
 
   if (fp->type != '{') {
     gts_file_error (fp, "expecting an opening brace");
hunk ./modules/bubbles.c 409
 
 static void bubble_fraction_write (GtsObject * o, FILE * fp)
 {
-  (* GTS_OBJECT_CLASS (gfs_bubble_fraction_class ())->parent_class->write) (o, fp);
+  (* GTS_OBJECT_CLASS (gfs_bubble_fraction_class ())->parent_class->write) (o, fp); 
   fprintf (fp, " { rkernel = %g ", GFS_BUBBLE_FRACTION (o)->rliq);
   fputs (" kernel =", fp);
   gfs_function_write (GFS_BUBBLE_FRACTION (o)->kernel_function, fp);
hunk ./modules/bubbles.c 446
       (GtsArgGetFunc) NULL
     };
     klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_particulate_field_class ()),
-				  &gfs_bubble_fraction_info);
+        &gfs_bubble_fraction_info);
   }
 
   return klass;
hunk ./modules/bubbles.c 465
 
 static void dVpdt_from_particles (FttCell * cell, BubbleData * p)
 {
+  FttVector pos;
+  ftt_cell_pos (cell, &pos);
+  distance_normalization (&pos, GFS_PARTICULATE (p->bubble));
   gdouble rad = pow (3.0*GFS_PARTICULATE (p->bubble)->volume/(4.0*M_PI), 1./3.);
hunk ./modules/bubbles.c 469
-  GFS_VALUE (cell, p->v) += 3.0*GFS_PARTICULATE (p->bubble)->volume
-    *p->bubble->velR/(p->bubble->vol_liq*rad);
+  GFS_VALUE (cell, p->v) += 4.*M_PI*pow(rad,2)*p->bubble->velR*gfs_function_spatial_value (p->bf->kernel_function, &pos)/p->correction;
 }
 
 static void bubble_fraction_dt_init (GtsObject * o)
hunk ./modules/bubbles.c 494
     klass = gts_object_class_new (GTS_OBJECT_CLASS ( gfs_bubble_fraction_class ()),
 				  &gfs_bubble_fraction_dt_info);
   }
-
   return klass;
 }
 
hunk ./modules/bubbles.c 499
 /** \endobject{GfsBubbleFractionDt} */
 
+/** \beginobject{GfsBubbleInteractions} */
+
+/* GfsBubbleInteractions: header */
+
+typedef struct _GfsBubbleInteractions   GfsBubbleInteractions;
+
+struct _GfsBubbleInteractions {
+  /*< private >*/
+  GfsEvent parent;
+
+  /*< public >*/
+  GfsParticleList * plist;
+};
+
+#define GFS_BUBBLE_INTERACTIONS(obj)            GTS_OBJECT_CAST (obj, GfsBubbleInteractions, gfs_bubble_interactions_class ())
+#define GFS_IS_BUBBLE_INTERACTIONS(obj)         (gts_object_is_from_class (obj, gfs_bubble_interactions_class ()))
+
+GfsVariableClass * gfs_bubble_interactions_class  (void);
+
+/* GfsBubbleInteractions: object */
+
+typedef struct {
+  GfsVariable * v, * p;
+  gdouble Rb3,Rb,sumRi2v,sumRi2;
+  GtsSListContainer * listp;
+  GfsBubble * b;
+} InteractionData;
+
+
+typedef struct {
+  FttVector * pos;
+  gdouble distance,pcell;
+  GfsVariable * p;
+} PcellData;
+
+
+static void averaged_pressure (FttCell * cell, gpointer data)
+{
+  PcellData * pcell = data;
+  pcell->pcell += ftt_cell_volume (cell)*GFS_VALUE(cell,pcell->p);
+  return;
+}
+
+static gdouble get_pcell (FttCell * cell, InteractionData * data) {
+
+  /*ensure that it executes after GfsBubbleFraction to obtain bubble->rliq*/
+  PcellData pcell = {  &GFS_PARTICLE (data->b)->pos,pow(data->b->vol_liq*3./(4.*M_PI), 1./3.),0, data->p };
+  CondData cd = { &GFS_PARTICLE (data->b)->pos,data->b->rliq};
+  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (data->p));
+
+  gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+      (FttCellTraverseFunc) averaged_pressure, &pcell,
+      cond_bubble, &cd);          
+  return pcell.pcell/data->b->vol_liq;
+}
+static void solve_one_bubble (FttCell * cell, InteractionData * data) {
+
+  GSList * i = data->listp->items;
+  GfsBubble * b = GFS_BUBBLE(i->data);
+  data->b = b; //Why did I do that ?? check
+  gdouble Ri= pow(3.*GFS_PARTICULATE(i->data)->volume/4./M_PI,1./3.);
+  gdouble Rb3 = data->Rb3;
+  gdouble Rb  = data->Rb;
+  gdouble sumRi2v  = data->sumRi2v;
+  gdouble sumRi2  = data->sumRi2;
+
+  GfsSimulation * sim = gfs_object_simulation(data->p); 
+  gdouble liq_rho = sim->physical_params.alpha ? 1./
+    gfs_function_value (sim->physical_params.alpha, cell) : 1.;
+
+  gdouble prescell = get_pcell(cell,data); 
+
+  gdouble radeq = pow(3.*b->vol_liq/(4.*M_PI),1./3.);
+  gdouble aux1 = 3./2.*Rb3/(pow(radeq,3)-Rb3)*pow(sumRi2v/sumRi2,2)*(1.-Rb/radeq);
+  gdouble aux2 = 3./2.*Rb*(pow(radeq,2)-pow(Rb,2))/(pow(radeq,3)-Rb3);
+
+  gdouble dpotdt = aux1 - 0.5*pow(b->velR,2) + (prescell-p_state_ec(b,Ri))/liq_rho;
+  dpotdt = dpotdt/(1. - aux2);
+  b->dpotdt = aux1 +  prescell/liq_rho + aux2*dpotdt;
+  b->dpotdt = b->dpotdt*liq_rho;
+}
+
+static void solve_cluster (FttCell * cell, InteractionData * data, gint nbubbles) {
+
+  gdouble ** m,dij,Ri,Rj,aux,prescell;
+  gint nb1,nb2;
+  GfsBubble * bi, * bj;
+  gdouble radeq;
+
+  gdouble Rb3 = data->Rb3;
+  gdouble Rb  = data->Rb;
+  gdouble sumRi2v  = data->sumRi2v;
+  gdouble sumRi2  = data->sumRi2;
+
+  GfsSimulation * sim = gfs_object_simulation (data->p); 
+  gdouble liq_rho = sim->physical_params.alpha ? 1./
+    gfs_function_value (sim->physical_params.alpha, cell) : 1.;
+
+  GSList * i,* j;
+  i = data->listp->items;
+
+  m = gfs_matrix_new (nbubbles, nbubbles, sizeof(gdouble));
+  gdouble * rhs = g_malloc0(nbubbles*sizeof(gdouble));
+  nb1 = 0;
+  while (i) {
+    bi = GFS_BUBBLE(i->data);
+    data->b = bi;
+    Ri= pow(3.*GFS_PARTICULATE (i->data)->volume/4./M_PI,1./3.);
+    prescell = get_pcell(cell,data); 
+    nb2 = 0;
+    j = data->listp->items;
+    while (j) {
+      Rj = pow(3.*GFS_PARTICULATE (j->data)->volume/4./M_PI,1./3.);
+      bj = GFS_BUBBLE(j->data);
+      if (nb1 == nb2) aux=1.;
+      else {
+        dij = ftt_vector_distance (&(GFS_PARTICLE(i->data)->pos), &(GFS_PARTICLE(j->data)->pos)); 
+        aux = MIN(Rj/dij,0.1); //restriction on the bubble interaction term
+      }
+      radeq = pow(3.*bj->vol_liq/(4.*M_PI),1./3.);
+      m[nb1][nb2]=aux-3./2.*Rb*(pow(radeq,2)-pow(Rb,2))/(pow(radeq,3)-Rb3)*pow(Rj,2)/sumRi2;
+      nb2 += 1;
+      j = j->next;
+    }
+    radeq = pow(3.*bi->vol_liq/(4.*M_PI),1./3.);
+    rhs[nb1] = 3./2.*Rb3/(pow(radeq,3)-Rb3)*pow(sumRi2v/sumRi2,2)*(1.-Rb/radeq) - 0.5*pow(bi->velR,2) \
+               + (prescell - p_state_ec(bi,Ri) )/liq_rho ; 
+    nb1 += 1;
+    i = i->next;
+  }
+
+  /* solve matrix*/
+  i = data->listp->items;
+  gdouble * dpotidt = g_malloc(nbubbles*sizeof(gdouble));
+
+  if (gfs_matrix_inverse (m, nbubbles, 1e-10)) {
+    for (nb1 = 0; nb1 < nbubbles; nb1++) { 
+      dpotidt[nb1] = 0.; 
+      for (nb2 = 0; nb2 < nbubbles; nb2++) 
+        dpotidt[nb1] += m[nb1][nb2]*rhs[nb2];
+    }
+  }
+  else { /* this may be a degenerate/isolated interface fragment */
+    g_warning ("singular matrix in bubble interactions");
+    for (nb1 = 0; nb1 < nbubbles; nb1++)  
+      dpotidt[nb1] = 0.;
+  }
+
+  /*term from finite scale of the cell*/
+  gdouble aux2 = 0.;
+
+  i = data->listp->items;
+  nb1=0.;
+  while (i) {
+    Ri= pow(3.*GFS_PARTICULATE (i->data)->volume/4./M_PI,1./3.);
+    aux2 += dpotidt[nb1]*pow(Ri,2);
+    i = i->next;
+    nb1++;
+  }
+
+  i = data->listp->items;
+  while (i) {
+    bi = GFS_BUBBLE(i->data);        
+    radeq = pow(3.*bi->vol_liq/(4.*M_PI),1./3.);
+    bi->dpotdt = aux2*3./2.*Rb*(pow(radeq,2)-pow(Rb,2))/(pow(radeq,3)-Rb3)/sumRi2;
+    bi->dpotdt += 3./2.*Rb3/(pow(radeq,3)-Rb3)*pow(sumRi2v/sumRi2,2)*(1.-Rb/radeq);
+  }
+
+  /*bubble-bubble interaction term*/
+  i = data->listp->items;
+  while (i) {
+    bi = GFS_BUBBLE(i->data);
+    j = data->listp->items;
+    nb2 = 0;
+    while (j) {
+      if (j != i) {
+        dij = ftt_vector_distance (&(GFS_PARTICLE(i->data)->pos), &(GFS_PARTICLE(j->data)->pos)); 
+        aux = MIN(Rj/dij,0.1); //restriction on the bubble interaction term
+        GFS_BUBBLE(i->data)->dpotdt -= dpotidt[nb2]*aux;
+      }
+      nb2++;
+      j=j->next;
+    }
+  }
+
+  g_free(dpotidt);
+  g_free(rhs);
+  gfs_matrix_free (m);
+  return;
+}
+
+static void interaction_bubbles(FttCell * cell, InteractionData * data)
+{
+  g_return_if_fail (cell != NULL);
+  g_return_if_fail (data != NULL);
+
+  gdouble Rb,sumRi2,sumRi2v,aux;
+
+  GtsSListContainer * listp = GFS_DOUBLE_TO_POINTER (GFS_VALUE (cell,data->v));
+  if (listp){
+    gint nbubbles = gts_container_size (GTS_CONTAINER (listp));
+
+    if (nbubbles > 10) {
+      GSList * j = listp->items;
+      while (j) {
+        GFS_BUBBLE(j->data)->dpotdt = 0.;
+        j = j->next;
+      }
+      return;
+    }
+
+    //Relevant quantities
+    Rb = 0; sumRi2 = 0; sumRi2v = 0;
+    GSList * j = listp->items;
+    while (j) {
+      aux = GFS_PARTICULATE (j->data)->volume;
+      Rb += aux;
+      aux = pow(3.*aux/4./M_PI,2./3.);
+      sumRi2 += aux;
+      sumRi2v += aux*GFS_BUBBLE(j->data)->velR;
+      j = j->next;
+    }
+    data->Rb3 = 3.*Rb/4./M_PI;
+    data->Rb = pow(data->Rb3,1./3.);
+    data->sumRi2v=sumRi2v;
+    data->sumRi2=sumRi2;
+    data->listp = listp;
+
+    if (nbubbles == 1) solve_one_bubble (cell,data);
+    else solve_cluster (cell,data,nbubbles);
+  }
+}
+
+
+static void destroy_list (FttCell * cell, GfsVariable * v)
+{
+  g_return_if_fail (cell != NULL);
+  g_return_if_fail (v != NULL);
+
+  GtsSListContainer * listp = GFS_DOUBLE_TO_POINTER (GFS_VALUE (cell,v));
+  if (listp){
+    gts_object_destroy (GTS_OBJECT (listp)); //do I need to destry something else?
+  }
+}
+
+static gboolean bubble_interactions_event (GfsEvent * event, 
+    GfsSimulation * sim) 
+{
+  if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_bubble_interactions_class ())->parent_class)->event)
+      (event, sim)) {
+
+    GfsDomain * domain = GFS_DOMAIN (sim); 
+    GtsSListContainer * listp ;
+    GfsBubbleInteractions * bint = GFS_BUBBLE_INTERACTIONS(event);
+    GfsVariable * sv = NULL;
+    GfsVariable * p = gfs_variable_from_name (domain->variables, "P");
+    sv = gfs_temporary_variable (domain);
+
+    gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+        (FttCellTraverseFunc) gfs_cell_reset, sv);
+    /* build lists
+       I think that the "build list" and "destroy list" should be a more general subroutine... 
+       probably in src/particle.c (discuss)*/
+    GSList * i = GFS_EVENT_LIST (bint->plist)->list->items; 
+    while (i) {
+      GfsParticle * part = GFS_PARTICLE (i->data);
+      FttCell * cellpart = gfs_domain_locate (domain, part->pos, -1, NULL);
+      if (cellpart) {
+        if (GFS_DOUBLE_TO_POINTER (GFS_VALUE (cellpart,sv))) listp = GFS_DOUBLE_TO_POINTER (GFS_VALUE (cellpart,sv));
+        else { 
+          listp = GTS_SLIST_CONTAINER (gts_container_new (GTS_CONTAINER_CLASS (gts_slist_container_class())));
+          GFS_DOUBLE_TO_POINTER (GFS_VALUE (cellpart,sv)) = listp;
+        }
+        gts_container_add (GTS_CONTAINER (listp), (GtsContainee *) part); // check if it is correct
+      }
+      i = i->next;
+    } 
+
+    /*solve for bubble potentials*/
+    InteractionData data = { sv, p }; 
+    gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+        (FttCellTraverseFunc) interaction_bubbles, &data);
+
+    /*destroy lists*/
+    gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+        (FttCellTraverseFunc) destroy_list, sv);
+
+    gts_object_destroy (GTS_OBJECT (sv));
+    return TRUE;
+  }
+  return FALSE;
+}
+
+static void bubble_interactions_read (GtsObject ** o, GtsFile * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_bubble_interactions_class ())->parent_class->read) (o, fp); 
+  if (fp->type == GTS_ERROR)
+    return;
+
+  if (fp->type != GTS_STRING) {
+    gts_file_error (fp, "expecting a string (object name)");
+    return;
+  }
+  GfsBubbleInteractions * pfield = GFS_BUBBLE_INTERACTIONS (*o);
+  GtsObject * object = gfs_object_from_name (GFS_DOMAIN (gfs_object_simulation (*o)), 
+      fp->token->str);
+  if (object == NULL) {
+    gts_file_error (fp, "unknown object '%s'", fp->token->str);
+    return;
+  }
+  if (!GFS_IS_PARTICLE_LIST (object)) {
+    gts_file_error (fp, "object '%s' is not a GfsParticleList", fp->token->str);
+    return;  
+  }
+  pfield->plist = GFS_PARTICLE_LIST (object);
+  gts_file_next_token (fp);
+
+}
+
+static void bubble_interactions_write (GtsObject * o, FILE * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_bubble_interactions_class ())->parent_class->write) (o, fp); 
+  fprintf (fp, " %s", GFS_EVENT (GFS_BUBBLE_INTERACTIONS (o)->plist)->name);
+}
+
+static void bubble_interactions_class_init (GtsObjectClass * klass)
+{
+  GFS_EVENT_CLASS (klass)->event = bubble_interactions_event;
+  klass->read =  bubble_interactions_read;
+  klass->write = bubble_interactions_write;
+}
+
+GfsVariableClass * gfs_bubble_interactions_class (void)
+{
+  static GfsVariableClass * klass = NULL;
+
+  if (klass == NULL) {
+    GtsObjectClassInfo gfs_bubble_interactions_info = {
+      "GfsBubbleInteractions",
+      sizeof (GfsBubbleInteractions),
+      sizeof (GfsVariableClass),
+      (GtsObjectClassInitFunc) bubble_interactions_class_init,
+      (GtsObjectInitFunc) NULL,
+      (GtsArgSetFunc) NULL,
+      (GtsArgGetFunc) NULL
+    };
+    klass = gts_object_class_new (GTS_OBJECT_CLASS ( gfs_event_class ()),
+        &gfs_bubble_interactions_info);
+  }
+
+  return klass;
+}
+
+/** \endobject{GfsBubbleInteractions} */
+
 /* Initialize module */
 
 const gchar gfs_module_name[] = "bubbles";
hunk ./modules/bubbles.c 864
   gfs_bubble_class ();
   gfs_bubble_fraction_class ();
   gfs_bubble_fraction_dt_class ();
+
+  gfs_bubble_interactions_class ();
   return NULL; 
 }
hunk ./modules/particulatecommon.c 24
 
 #include "particulatecommon.h"
 #include "source.h"
+#include "refine.h"
+#include "adaptive.h"
+#include "domain.h"
+#include "fluid.h"
+#include "solid.h"
+#include "vof.h"
+#include "mpi_boundary.h"
 
 /* Forces on the Particle */
 
hunk ./modules/particulatecommon.c 193
   for (c = 0; c < FTT_DIMENSION; c++)
     (&fluid_vel.x)[c] = gfs_interpolate (cell, p->pos, u[c]);
 
-  FttVector relative_vel = subs_fttvectors (&fluid_vel, &particulate->vel);
+  FttVector relative_vel = subs_fttvectors (&fluid_vel,&particulate->vel);
   FttVector vorticity;
   vorticity_vector (cell, u, &vorticity);
 
hunk ./modules/particulatecommon.c 487
      
   for ( c = 0 ; c < FTT_DIMENSION; c++)
     (&total_force.x)[c] = (&new_force.x)[c]*p->volume + (&p->force.x)[c];
+  
     
   p->force = total_force;
 }
hunk ./modules/particulatecommon.c 497
 {
   GfsParticle * p = GFS_PARTICLE (event);
   GfsParticulate * particulate = GFS_PARTICULATE (event);
-
+ 
   if (particulate->forces == NULL)
     (* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_particulate_class ())->parent_class)->event)
       (event, sim);
hunk ./modules/particulatecommon.c 503
   else {
     FttVector pos = p->pos;
-    gfs_simulation_map (sim, &pos);
-
+    p->pos_old = pos;
     FttComponent c;
     /* Velocity Verlet Algorithm */
     for (c = 0; c < FTT_DIMENSION; c++) {
hunk ./modules/particulatecommon.c 512
       (&particulate->vel.x)[c] += (&particulate->force.x)[c]*sim->advection_params.dt
 	/(2.*particulate->mass);
     }
-
+    
     /* Compute forces */
     for (c = 0; c < FTT_DIMENSION; c++)
       (&particulate->force.x)[c] = 0.;      
hunk ./modules/particulatecommon.c 518
     gts_container_foreach (GTS_CONTAINER (particulate->forces), 
 			   (GtsFunc) compute_forces, particulate);
-
+    
     for (c = 0; c < FTT_DIMENSION; c++)
       (&particulate->vel.x)[c] += 
 	(&particulate->force.x)[c]*sim->advection_params.dt/(2.*particulate->mass);
hunk ./modules/particulatecommon.c 522
-
-    gfs_simulation_map_inverse (sim, &pos);
+    
     p->pos = pos;   
   }
   return TRUE;
hunk ./modules/particulatecommon.c 549
     return;
   }
   gdouble L = gfs_object_simulation (*o)->physical_params.L;
-// L is not correctly initialized. WHY???
-//  printf("L %g \n", L);
   p->volume = atof (fp->token->str);
hunk ./modules/particulatecommon.c 550
-//  p->volume /= pow(L, FTT_DIMENSION);
+  p->volume /= pow(L, FTT_DIMENSION);
+
   gts_file_next_token (fp);
 
hunk ./modules/particulatecommon.c 554
-  if (fp->type != GTS_INT && fp->type != GTS_FLOAT) {
+  if (fp->type != GTS_INT && fp->type != GTS_FLOAT) {    
     gts_file_error (fp, "expecting a number (v.x)");
     return;
   }
hunk ./modules/particulatecommon.c 558
-  p->vel.x = atof (fp->token->str)/L;
+  p->vel.x = atof (fp->token->str);
   gts_file_next_token (fp);
   
   if (fp->type != GTS_INT && fp->type != GTS_FLOAT) {
hunk ./modules/particulatecommon.c 565
     gts_file_error (fp, "expecting a number (v.y)");
     return;
   }
-  p->vel.y = atof (fp->token->str)/L;
+  p->vel.y = atof (fp->token->str);
   gts_file_next_token (fp);
   
   if (fp->type != GTS_INT && fp->type != GTS_FLOAT) {
hunk ./modules/particulatecommon.c 572
     gts_file_error (fp, "expecting a number (v.z)");
     return;
   }
-  p->vel.z = atof (fp->token->str)/L;
+  p->vel.z = atof (fp->token->str);
   gts_file_next_token (fp);
 
   if (fp->type == GTS_INT || fp->type == GTS_FLOAT) {
hunk ./modules/particulatecommon.c 576
-    p->force.x = atof (fp->token->str)/L;
+    p->force.x = atof (fp->token->str);
     gts_file_next_token (fp);
   }
   
hunk ./modules/particulatecommon.c 581
   if (fp->type == GTS_INT || fp->type == GTS_FLOAT) {
-    p->force.y = atof (fp->token->str)/L;
+    p->force.y = atof (fp->token->str);
     gts_file_next_token (fp);
   }
   
hunk ./modules/particulatecommon.c 586
   if (fp->type == GTS_INT || fp->type == GTS_FLOAT) {
-    p->force.z = atof (fp->token->str)/L;
+    p->force.z = atof (fp->token->str);
     gts_file_next_token (fp);
   }
hunk ./modules/particulatecommon.c 589
+
+  gfs_simulation_map(gfs_object_simulation(*o), &p->vel);
+  gfs_simulation_map(gfs_object_simulation(*o), &p->force);
 }
 
 static void gfs_particulate_write (GtsObject * o, FILE * fp)
hunk ./modules/particulatecommon.c 599
   (* GTS_OBJECT_CLASS (gfs_particulate_class ())->parent_class->write) (o, fp);
  
  GfsParticulate * p = GFS_PARTICULATE (o);
-  gdouble L = gfs_object_simulation (o)->physical_params.L;
-  //fprintf (fp, " %g %g %g %g %g", p->mass, p->volume*pow(L, FTT_DIMENSION), 
-  //             p->vel.x*L, p->vel.y*L, p->vel.z*L);
-  fprintf (fp, " %g %g %g %g %g", p->mass, p->volume, 
-               p->vel.x*L, p->vel.y*L, p->vel.z*L);
-  fprintf (fp, " %g %g %g", p->force.x*L, p->force.y*L, p->force.z*L);
+ gdouble L = gfs_object_simulation (o)->physical_params.L;
+
+ gfs_simulation_map_inverse(gfs_object_simulation(o), &p->vel);
+ gfs_simulation_map_inverse(gfs_object_simulation(o), &p->force);
+
+ fprintf (fp, " %g %g %g %g %g", p->mass, p->volume*pow(L, FTT_DIMENSION), 
+	  p->vel.x, p->vel.y, p->vel.z);
+ fprintf (fp, " %g %g %g", p->force.x, p->force.y, p->force.z);
+
+ gfs_simulation_map(gfs_object_simulation(o), &p->vel);
+ gfs_simulation_map(gfs_object_simulation(o), &p->force);
 }
 
 static void gfs_particulate_class_init (GfsEventClass * klass)
hunk ./modules/particulatecommon.c 639
 }
 
 /* GfsParticleList: Object */
+static void remove_particles_not_in_domain(GfsEvent * event, GfsParticleList *plist)
+{
+ 
+  GfsSimulation *sim = gfs_object_simulation(plist);
+  GfsDomain *domain = GFS_DOMAIN(sim);
 
hunk ./modules/particulatecommon.c 645
+  GfsParticle *p = GFS_PARTICLE(event);  
+  FttCell * cell = gfs_domain_locate(domain, p->pos, -1, NULL);
+ 
+  if(cell==NULL){   
+       gts_container_remove(GTS_CONTAINER(GFS_EVENT_LIST(plist)->list),GTS_CONTAINEE(event));    
+       gts_object_destroy(GTS_OBJECT(event));
+  }
+ 
+}
+
+struct _GfsRequest {  
+  FILE * fp;
+  long length;
+#ifdef HAVE_MPI
+  MPI_Request request[2];
+  void * buf;
+#endif
+};
+
+
+static GSList * gfs_receive_particles (GfsDomain * domain, int src,GfsEventList *l)
+{
+  g_return_val_if_fail (domain != NULL, NULL);
+
+#ifdef HAVE_MPI
+  MPI_Status status;
+  long length;
+  MPI_Recv (&length, 1, MPI_LONG, src, 0, MPI_COMM_WORLD, &status);
+  /*  g_log (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, "receiving %ld bytes from PE %d", length, src); */
+  if (length > 0) {
+    char * buf = g_malloc (length);
+    MPI_Recv (buf, length, MPI_BYTE, src, 1, MPI_COMM_WORLD, &status);
+    FILE * f = tmpfile ();
+    fwrite (buf, 1, length, f);
+    rewind (f);
+    GtsFile * fp = gts_file_new (f);
+    GSList * list = NULL;   
+    GtsObjectClass * klass = l->klass;    
+    while (fp->type == GTS_INT) {
+      if (klass == NULL)
+	g_error ("gfs_receive_particles():%d:%d: unknown class '%s'", 
+		 fp->line, fp->pos, fp->token->str);
+      GtsObject * object = gts_object_new (klass);
+      gfs_object_simulation_set (object, domain);
+      g_assert (klass->read);
+      (* klass->read) (&object, fp);
+      if (fp->type == GTS_ERROR)
+	g_error ("gfs_receive_particles():%d:%d: %s", fp->line, fp->pos, fp->error);
+      list = g_slist_prepend (list, object);
+      while (fp->type == '\n')
+	gts_file_next_token (fp);
+    }
+    gts_file_destroy (fp);
+    fclose (f);
+    g_free (buf);
+    return list;
+  }
+#endif /* HAVE_MPI */
+  return NULL;
+}
+
+
+static void collect_particles_in_rank_zero(GfsEventList *l, GfsSimulation *sim)
+{
+#ifdef HAVE_MPI  
+  int rank;
+  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
+  int comm_size;
+  MPI_Comm_size (MPI_COMM_WORLD, &comm_size); 
+  GfsDomain *domain = GFS_DOMAIN(sim);
+  if(rank>0){
+    GfsRequest * request = gfs_send_objects(l->list->items,0);
+    gfs_wait(request);
+  }
+  else{
+    int src;
+    for(src = 1; src < comm_size; src++){
+      GSList *list = gfs_receive_particles (domain, src,l);
+      while(list){
+	GtsObject * object = (GtsObject *)(list->data);
+	GfsEvent * event = GFS_EVENT (l);
+	gfs_event_set (GFS_EVENT (object),
+		       event->start, event->end, event->step, event->istart, event->iend, event->istep);
+	gts_container_add(GTS_CONTAINER(l->list),GTS_CONTAINEE(object));
+	list = list->next;
+      }
+    }
+  }
+#endif /* HAVE_MPI */
+}
+
+static gboolean gfs_particle_list_event (GfsEvent * event, 
+				       GfsSimulation * sim)
+{
+
+  GfsParticleList *p = GFS_PARTICLE_LIST(event);
+  GfsEventList *l = GFS_EVENT_LIST(event);
+
+  gts_container_foreach (GTS_CONTAINER (l->list), (GtsFunc)remove_particles_not_in_domain, p);
+  
+  if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_particle_list_class ())->parent_class)->event)
+      (event, sim)) {
+    
+    gfs_particle_bc (GFS_PARTICLE_LIST(event)); 
+
+    /*FixMe Call the function below only when required*/    
+    collect_particles_in_rank_zero(l, sim);
+    
+    return TRUE;
+  }  
+  return FALSE;
+  
+}
 static void assign_forces(GfsParticulate *particulate, GtsSListContainer *forces)
 {
   particulate->forces = forces;
hunk ./modules/particulatecommon.c 831
   if(fp->type == GTS_INT){
     p->idlast = atoi (fp->token->str);
     gts_file_next_token (fp);
-  }    
+  }
+
+  p->first_call = TRUE;
+
 }
 
 static void gfs_particle_list_write (GtsObject * o, FILE * fp)
hunk ./modules/particulatecommon.c 876
 
 static void gfs_particle_list_class_init (GtsObjectClass * klass)
 {
+  GFS_EVENT_CLASS (klass)->event = gfs_particle_list_event;
   klass->read = gfs_particle_list_read;
   klass->write = gfs_particle_list_write;  
hunk ./modules/particulatecommon.c 879
-  klass->destroy = gfs_particle_list_destroy;  
+  klass->destroy = gfs_particle_list_destroy;
 }
 
 GfsEventClass * gfs_particle_list_class (void)
hunk ./modules/particulatecommon.c 902
   return klass;
 }
 
+/** \beginobject{GfsDropletToParticle} */ 
+
 typedef struct {
   FttVector pos, vel;
   gdouble volume;
hunk ./modules/particulatecommon.c 952
   }  
 }
 
-static void convert_droplets (GfsDomain * domain, 
-			      DropletsPar * pars, GfsParticleList * plist)
+static gint particle_id(GfsParticleList * plist)
+{
+  return ++plist->idlast;
+}
+
+
+static void add_particulate (GfsParticulate data_part,
+                             GfsParticleList * plist)
 {
hunk ./modules/particulatecommon.c 961
+  guint c;
   GfsSimulation * sim = gfs_object_simulation (plist); 
hunk ./modules/particulatecommon.c 963
-  guint i;
-  
-  GfsDropletToParticle * d = DROPLET_TO_PARTICLE (plist);
   GfsEventList * l = GFS_EVENT_LIST (plist); 
hunk ./modules/particulatecommon.c 964
+  GtsObjectClass * klass = l->klass;
+  if (klass == NULL) {
+    gfs_error (0, "Unknown particle class\n");
+    return;
+  }
+  GtsObject * object = gts_object_new (klass);
+  gfs_object_simulation_set (object, sim);
+  l->list->items = g_slist_reverse (l->list->items);	
+  gts_container_add (GTS_CONTAINER (l->list), GTS_CONTAINEE (object));
+  l->list->items = g_slist_reverse (l->list->items);
+  GfsEvent * list = GFS_EVENT (l);	
+  gfs_event_set (GFS_EVENT (object), 
+                 list->start, list->end, list->step, list->istart, list->iend, list->istep);
+  GfsParticulate * part = GFS_PARTICULATE (object);
+  GfsParticle * p = GFS_PARTICLE (part);
+  
+  part->vel = data_part.vel;
+  p->pos = data_part.parent.pos;
+  part->volume = data_part.volume;
+  p->id = particle_id(plist);
+  part->mass = data_part.mass;
+  for (c = 0; c < FTT_DIMENSION; c++)
+    (&part->force.x)[c] = 0.;
+  assign_forces ( part , plist->forces);
+}
 
hunk ./modules/particulatecommon.c 990
+static void convert_droplets (GfsDomain * domain, 
+			      DropletsPar * pars, GfsDropletToParticle * d)
+{
+  GfsSimulation * sim = gfs_object_simulation (d); 
+  guint i;
+  
   pars->sizes = g_malloc0 (pars->n*sizeof (guint));  
   pars->drops = g_malloc0 (pars->n*sizeof (Droplets));
 
hunk ./modules/particulatecommon.c 1034
   
   for (i = 0; i < pars->n; i++) {
     if (pars->sizes[i] < pars->min){
+      GfsParticulate newpart; 
       for (c = 0; c < FTT_DIMENSION; c++) {
hunk ./modules/particulatecommon.c 1036
-      	(&pars->drops[i].pos.x)[c] = (&pars->drops[i].pos.x)[c]/pars->sizes[i];
-	(&pars->drops[i].vel.x)[c] = (&pars->drops[i].vel.x)[c]/pars->sizes[i];
+      	(&newpart.parent.pos.x)[c] = (&pars->drops[i].pos.x)[c]/pars->sizes[i];
+	(&newpart.vel.x)[c] = (&pars->drops[i].vel.x)[c]/pars->sizes[i];
       }
hunk ./modules/particulatecommon.c 1039
-      FttCell * cell = gfs_domain_locate (domain, pars->drops[i].pos, -1, NULL);    
+      FttCell * cell = gfs_domain_locate (domain, newpart.parent.pos, -1, NULL);    
       if (cell) {
hunk ./modules/particulatecommon.c 1041
-	/* Construct an Object */
-	GtsObjectClass * klass = l->klass;
-	if (klass == NULL) {
-	  gfs_error (0, "Unknown particle class\n");
-	  return;
-	}
-	GtsObject * object = gts_object_new (klass);
-	gfs_object_simulation_set (object, sim);
-	l->list->items = g_slist_reverse (l->list->items);	
-	gts_container_add (GTS_CONTAINER (l->list), GTS_CONTAINEE (object));
-	l->list->items = g_slist_reverse (l->list->items);
-	GfsEvent * list = GFS_EVENT (l);	
-	gfs_event_set (GFS_EVENT (object), 
-		       list->start, list->end, list->step, list->istart, list->iend, list->istep);
-	GfsParticulate * drop = GFS_PARTICULATE (object);
-	GfsParticle * p = GFS_PARTICLE (drop);
-	
-	drop->vel = pars->drops[i].vel;
-	p->pos = pars->drops[i].pos;
-	drop->volume = pars->drops[i].volume;
-	p->id = ++plist->idlast;
-	drop->mass = sim->physical_params.alpha ? 1./
+	newpart.volume = pars->drops[i].volume;
+	newpart.mass = sim->physical_params.alpha ? 1./
 	  gfs_function_value (sim->physical_params.alpha, cell) : 1.;
hunk ./modules/particulatecommon.c 1044
-	drop->mass *= drop->volume;
-	for (c = 0; c < FTT_DIMENSION; c++)
-	  (&drop->force.x)[c] = 0.;
+	newpart.mass *= newpart.volume;
+        add_particulate (newpart,d->plist);
       }       
     }   
   }  
hunk ./modules/particulatecommon.c 1058
 
 /* GfsDropletToParticle: object */
 
-static void compute_v (FttCell * cell, GfsRemoveDroplets * d)
+typedef struct {                                                                                                        GfsVariable * v;
+  GfsFunction * fc;
+} compute_v_data;  
+
+static void compute_v (FttCell * cell, compute_v_data * d)
 {
   GFS_VALUE (cell, d->v) = gfs_function_value (d->fc, cell);
 }
hunk ./modules/particulatecommon.c 1072
   if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_droplet_to_particle_class ())->parent_class)->event)
       (event, sim)) {  
     GfsDomain * domain = GFS_DOMAIN (sim);
-    GfsParticleList * plist = GFS_PARTICLE_LIST (event);
     GfsDropletToParticle *d = DROPLET_TO_PARTICLE (event);
hunk ./modules/particulatecommon.c 1073
-    d->v = d->fc ? gfs_function_get_variable (d->fc) : d->c;
+    GfsVariable * v = d->fc ? gfs_function_get_variable (d->fc) : d->c;
     DropletsPar p ;   
   
     p.resetval = d->resetwith;
hunk ./modules/particulatecommon.c 1082
     p.density = d->density;
     p.t = d->c;
   
-    if (d->v){
-      p.c = d->v;
+    if (v){
+      p.c = v;
       p.n = gfs_domain_tag_droplets (domain, p.c, p.tag);
       if (p.n > 0 && -d->min < (gint) p.n){
 	p.c = d->c;
hunk ./modules/particulatecommon.c 1087
-	convert_droplets (domain, &p, plist);
+	convert_droplets (domain, &p, d);
       }
     }
     else {      
hunk ./modules/particulatecommon.c 1091
-      d->v = gfs_temporary_variable (domain);      
+      v = gfs_temporary_variable (domain);      
+      compute_v_data cvd = { v , d->fc };
       gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,
hunk ./modules/particulatecommon.c 1094
-				(FttCellTraverseFunc) compute_v, d);
-      p.c = d->v;      
+				(FttCellTraverseFunc) compute_v, &cvd);
+      p.c = v;      
       p.n = gfs_domain_tag_droplets (domain, p.c, p.tag);
       if (p.n > 0 && -d->min < (gint) p.n){
 	p.c = d->c;	
hunk ./modules/particulatecommon.c 1099
-	convert_droplets (domain, &p, plist);	
+	convert_droplets (domain, &p, d);	
       }              
hunk ./modules/particulatecommon.c 1101
-      gts_object_destroy (GTS_OBJECT (d->v));      
+      gts_object_destroy (GTS_OBJECT (v));      
     } 
 
     gts_object_destroy (GTS_OBJECT (p.tag));
hunk ./modules/particulatecommon.c 1117
   if (fp->type == GTS_ERROR)
     return;
 
+  if (fp->type != GTS_STRING) {
+    gts_file_error (fp, "expecting a string (object name)");
+    return;
+  }
+
   GfsDropletToParticle * r = DROPLET_TO_PARTICLE (*o);  
hunk ./modules/particulatecommon.c 1123
-  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (r));
+
+  GtsObject * object = gfs_object_from_name (GFS_DOMAIN (gfs_object_simulation (*o)), 
+					     fp->token->str);
+  if (object == NULL) {
+    gts_file_error (fp, "unknown object '%s'", fp->token->str);
+    return;
+  }
+  if (!GFS_IS_PARTICLE_LIST (object)) {
+    gts_file_error (fp, "object '%s' is not a GfsParticleList", fp->token->str);
+    return;  
+  }
+  gts_file_next_token (fp);
+  
+  r->plist = GFS_PARTICLE_LIST (object);
 
   if (fp->type != GTS_STRING) {
     gts_file_error (fp, "expecting a string (variable)");
hunk ./modules/particulatecommon.c 1143
     return;
   }
 
+  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (r));
+
   if ((r->c = gfs_variable_from_name (domain->variables, fp->token->str)) == NULL) {
     gts_file_error (fp, "unknown variable `%s'", fp->token->str);
     return;
hunk ./modules/particulatecommon.c 1177
   (* GTS_OBJECT_CLASS (gfs_droplet_to_particle_class ())->parent_class->write) (o, fp);
 
   GfsDropletToParticle * r = DROPLET_TO_PARTICLE(o);
-
+  
+  fprintf (fp, " %s", GFS_EVENT (r->plist)->name);
+  
   fprintf (fp, " %s { min = %d reset = %g density = %g } ",
 	   r->c->name, r->min, r->resetwith, r->density);
   if (r->fc)
hunk ./modules/particulatecommon.c 1224
       (GtsArgSetFunc) NULL,
       (GtsArgGetFunc) NULL
     };
-    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_particle_list_class ()),
+    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_event_class ()),
 				  &gfs_droplet_to_particle_info);
   }
   return klass;
hunk ./modules/particulatecommon.c 1230
 }
 
-/* GfsParticulateField: object */
+/** \endobject{GfsDropletToParticle} */
+
+/** \beginobject{GfsParticleToDroplet} */
+
+typedef struct {
+  guint maxlevel;
+  GfsDomain * domain;
+  GfsGenericSurface * surface;
+  gboolean check;
+} RefineCut;
+
+static void save_p_solid (FttCell * cell, gpointer * data)
+{
+  GfsVariable * c = data[0];
+  GfsVariable * save_prev = data[3];
+
+  GFS_VALUEI (cell, save_prev->i) = GFS_VALUEI (cell, c->i);
+  GFS_DOUBLE_TO_POINTER (GFS_VALUEI (cell, c->i)) = GFS_STATE (cell)->solid;
+  GFS_STATE (cell)->solid = NULL;
+}
+
+static void restore_p_solid (FttCell * cell, gpointer * data)
+{
+  GfsVariable * c = data[0];
+  gboolean * not_cut = data[1];
+  GfsVariable * status = data[2];
+
+  GfsSolidVector * solid = GFS_STATE (cell)->solid;
+
+  GFS_STATE (cell)->solid = GFS_DOUBLE_TO_POINTER (GFS_VALUEI (cell, c->i));
+
+  if (solid) {
+    GFS_VALUEI (cell, c->i) =  solid->a;
+    g_free (solid);
+    *not_cut = FALSE;
+  }
+  else if (GFS_VALUEI (cell, status->i) == 0.) {
+    /* fixme: this can fail for non-contiguous domains (e.g. non-connected GfsBoxes) */
+    g_assert (*not_cut);
+    GFS_VALUEI (cell, c->i) = 0.;
+  }
+  else {
+    g_assert (GFS_VALUEI (cell, status->i) == 1. || GFS_VALUEI (cell, status->i) == 2.);
+    GFS_VALUEI (cell, c->i) =  GFS_VALUEI (cell, status->i) - 1.;
+  }
+}
+
+static void add_to_prev_void (FttCell * cell, gpointer * data)
+{
+  GfsVariable * c = data[0];
+  GfsVariable * save_prev = data[3];
+  GfsParticulate *p = GFS_PARTICULATE((GfsParticle *)data[4]);
+  GfsDomain *domain = data[5];
+  GfsVariable **u = gfs_domain_velocity(domain);
+
+  if(GFS_VALUE (cell, c) > 0.){
+    guint j;
+    for(j = 0; j < FTT_DIMENSION; j++)
+      GFS_VALUE(cell, u[j]) = (&p->vel.x)[j];
+  }
+
+  GFS_VALUEI (cell, c->i) += GFS_VALUEI (cell, save_prev->i);
+
+  if(GFS_VALUE (cell, c) > 1.0)
+    GFS_VALUEI (cell, c->i) = 1.0;
+  else if (GFS_VALUE (cell, c) < 0.0)
+      GFS_VALUEI (cell, c->i) = 0.0;
+}
+
+static void gfs_domain_assign_fraction (GfsDomain * domain,
+			       GfsGenericSurface * s,
+			       GfsVariable * c,  GfsParticle *p)
+{
+  gboolean not_cut = TRUE;
+  gpointer data[6];
+  GfsVariable * status, *save_prev;
+
+  g_return_if_fail (domain != NULL);
+  g_return_if_fail (s != NULL);
+  g_return_if_fail (c != NULL);
+
+  status = gfs_temporary_variable (domain);
+
+  save_prev = gfs_temporary_variable (domain);
+  data[0] = c;
+  data[1] = &not_cut;
+  data[2] = status;
+  data[3] = save_prev;
+  data[4] = p;
+  data[5] = domain;
+
+  gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,
+			    (FttCellTraverseFunc) save_p_solid, data);
+
+  GfsSolid tmp;
+  tmp.s = s;
+  GSList * l = g_slist_prepend (NULL, &tmp);
+
+  gfs_domain_init_solid_fractions (domain, l, FALSE, NULL, NULL, status);
+
+  if(l)  g_slist_free (l);
+
+  gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,
+			    (FttCellTraverseFunc) restore_p_solid, data);
+
+  gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,
+  			    (FttCellTraverseFunc) add_to_prev_void, data);
+
+  gts_object_destroy (GTS_OBJECT (status));
+  gts_object_destroy (GTS_OBJECT (save_prev));
+
+}
+
+
+static void generate_surface(GfsSurface *surface, GfsSurface *shape, gdouble rad, GfsParticle *p)
+{
+
+  memcpy(surface, shape, sizeof(GfsSurface));
+
+  surface->translate[0] = p->pos.x;
+  surface->translate[1] = p->pos.y;
+  surface->translate[2] = p->pos.z;
+
+  GtsMatrix * m = gts_matrix_translate (NULL, surface->translate);
+
+  surface->scale[0] = rad;
+  surface->scale[1] = rad;
+  surface->scale[2] = rad;
+
+  GtsMatrix * ms = gts_matrix_scale (NULL, surface->scale);
+  if (surface->m)
+    gts_matrix_destroy (surface->m);
+  surface->m = gts_matrix_product (m, ms);
+  gts_matrix_destroy (m);
+  gts_matrix_destroy (ms);
+      
+  if (surface->s) {
+    gts_surface_foreach_vertex (surface->s, (GtsFunc) gts_point_transform, surface->m);
+    gts_matrix_destroy (surface->m);
+    surface->m = NULL;
+    if (surface->flip)
+      gts_surface_foreach_face (surface->s, (GtsFunc) gts_triangle_revert, NULL);
+  }
+  else {
+    GtsMatrix * i = gts_matrix_inverse (surface->m);
+    gts_matrix_destroy (surface->m);
+    surface->m = i;
+  }
+}
+
+static double compute_xyz (FttCell * cell, GfsParticleToDroplet * d)
+{
+  if(d->fc)
+    return gfs_function_value (d->fc, cell);
+  else
+    return -1.0;
+}
+
+#define PROXIMITY_FRAC 0.25
+
+typedef struct {
+  GfsVariable *v;
+  gboolean check;
+} ProximityCheck;
+
+
+static void check_cut_cells(FttCell *cell, GfsGenericSurface *s, ProximityCheck *proximity)
+{
+  GfsVariable *v = proximity->v;
+ 
+  if(!proximity->check){
+    if(GFS_VALUE(cell, v) > PROXIMITY_FRAC){
+      proximity->check = TRUE;
+    }
+  }
+}
+
+static gboolean check_proximity(GfsVariable *v, GfsGenericSurface *surface)
+{
+
+  GfsDomain *domain = GFS_DOMAIN(gfs_object_simulation(v));
+  ProximityCheck proximity;
+  proximity.v = v;
+  proximity.check = FALSE;
+
+  gfs_domain_traverse_cut (domain,
+			   surface,
+			   FTT_PRE_ORDER,
+			   FTT_TRAVERSE_LEAFS,
+			   (FttCellTraverseCutFunc) check_cut_cells,
+			   &proximity);
+ 
+  return proximity.check;
+}
+
+static void refine_implicit_p_cell (FttCell * cell, RefineCut * p)
+{
+  guint maxlevel = p->maxlevel;
+
+  if (ftt_cell_level (cell) < maxlevel && (gfs_cell_is_cut (cell, p->surface, FALSE, maxlevel))){
+    ftt_cell_refine_single (cell, p->domain->cell_init, p->domain->cell_init_data);
+    p->check = TRUE;
+  }
+}
+
+static void convert_particles(GfsEvent * event, GfsParticleToDroplet *d)
+{
+  GfsSimulation *sim = gfs_object_simulation(d);
+  GfsDomain *domain = GFS_DOMAIN(sim);
+  
+  GfsParticulate * p = GFS_PARTICULATE(event);
+  GfsParticle *particle = GFS_PARTICLE(event);
+
+  gdouble rad = pow(p->volume/M_PI,1./2.);
+#if !FTT_2D
+  rad = pow(3.0*(p->volume)/4.0/M_PI, 1./3.);
+#endif
+  GfsGenericSurface * surface = GFS_GENERIC_SURFACE (gts_object_new 
+					      (GTS_OBJECT_CLASS (gfs_surface_class ())));
+  generate_surface (GFS_SURFACE(surface), d->shape, rad, particle);
+  
+  FttCell * cellpart = gfs_domain_locate (domain, particle->pos, -1, NULL);
+  
+  gboolean check = FALSE;
+  if(rad > ftt_cell_size(cellpart))
+    check = check_proximity(d->c, surface);
+  else
+    if(GFS_VALUE(cellpart, d->c) > PROXIMITY_FRAC)
+      check = TRUE;    
+
+  if(cellpart && (compute_xyz(cellpart, d) < 0 || check) ){ 
+
+    RefineCut prefine;
+    prefine.domain = domain;
+    prefine.maxlevel = d->maxlevel;    
+    prefine.surface = surface;
+    prefine.check = TRUE;
+    while(prefine.check){
+      prefine.check = FALSE;
+      gfs_domain_cell_traverse (domain,
+				FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+				(FttCellTraverseFunc) refine_implicit_p_cell, &prefine);
+    }
+      gfs_domain_assign_fraction (domain,
+				  surface,
+				  d->c, particle);
+
+      gts_container_remove(GTS_CONTAINER(GFS_EVENT_LIST(d->plist)->list),GTS_CONTAINEE(event));
+      gts_object_destroy (GTS_OBJECT (event));
+        
+  }
+
+  if (GFS_SURFACE(surface)->s)
+    gts_object_destroy (GTS_OBJECT (GFS_SURFACE(surface)->s));
+  
+  if (GFS_SURFACE(surface)->m)
+    gts_matrix_destroy (GFS_SURFACE(surface)->m);
+}
+
+static gboolean gfs_particle_to_droplet_event (GfsEvent * event, 
+					 GfsSimulation * sim) 
+{
+  if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_particle_to_droplet_class ())->parent_class)->event)
+      (event, sim)) {
+
+    GfsDomain * domain = GFS_DOMAIN (sim);
+    GfsParticleToDroplet *d = GFS_PARTICLE_TO_DROPLET(event);
+    GfsParticleList *plist = d->plist;
+
+    GfsEventList *l = GFS_EVENT_LIST(plist);
+
+    gts_container_foreach (GTS_CONTAINER (l->list), (GtsFunc)convert_particles, d); 
+
+    gfs_domain_reshape (domain, gfs_domain_depth(domain));
+    
+    return TRUE;
+  }
+  return FALSE;
+}
+
+static void gfs_particle_to_droplet_read (GtsObject ** o, GtsFile * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_particle_to_droplet_class ())->parent_class->read) (o, fp); 
+  if (fp->type == GTS_ERROR)
+    return;
+
+  if (fp->type != GTS_STRING) {
+    gts_file_error (fp, "expecting a string (object name)");
+    return;
+  }
+
+  GfsParticleToDroplet * p = GFS_PARTICLE_TO_DROPLET (*o);
+  GtsObject * object = gfs_object_from_name (GFS_DOMAIN (gfs_object_simulation (*o)), 
+					     fp->token->str);
+  if (object == NULL) {
+    gts_file_error (fp, "unknown object '%s'", fp->token->str);
+    return;
+  }
+  if (!GFS_IS_PARTICLE_LIST (object)) {
+    gts_file_error (fp, "object '%s' is not a GfsParticleList", fp->token->str);
+    return;  
+  }
+  gts_file_next_token (fp);
+  
+  p->plist = GFS_PARTICLE_LIST (object);
+
+  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (p));
+  
+  if (fp->type != GTS_STRING) {
+    gts_file_error (fp, "expecting a string (variable)");
+    return;
+  }
+
+  if ((p->c = gfs_variable_from_name (domain->variables, fp->token->str)) == NULL) {
+    gts_file_error (fp, "unknown variable `%s'", fp->token->str);
+    return;
+  }
+  gts_file_next_token (fp);
+
+  if (fp->type == '{') {
+    GtsFileVariable var[] = {
+      {GTS_INT, "maxlevel",  TRUE},
+      {GTS_NONE}
+    };
+    
+    var[0].data = &p->maxlevel;
+    gts_file_assign_variables (fp, var);
+  }
+
+  while(fp->type == '\n')
+    gts_file_next_token (fp);
+  
+  p->shape = GFS_SURFACE (gts_object_new (GTS_OBJECT_CLASS (gfs_surface_class ())));
+  gfs_generic_surface_read (GFS_GENERIC_SURFACE(p->shape), gfs_object_simulation (*o), fp);  
+  
+  if (fp->type != '\n') {
+    p->fc = gfs_function_new (gfs_function_class (), 0.);
+    gfs_function_read (p->fc, gfs_object_simulation (p), fp);
+  }
+
+}
+
+static void gfs_particle_to_droplet_write (GtsObject * o, FILE * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_particle_to_droplet_class ())->parent_class->write) (o, fp); 
+
+  GfsParticleToDroplet * r = GFS_PARTICLE_TO_DROPLET(o);
+
+  fprintf (fp, " %s", GFS_EVENT (r->plist)->name);
+
+  fprintf (fp, " %s ",
+	   r->c->name);
+  
+  if (r->shape) {
+    fputs (" ( ", fp);
+    gfs_function_write (r->shape->f, fp);
+    fputs (" ) ", fp);
+  }
+  
+  if (r->fc)
+    gfs_function_write (r->fc, fp);
+
+}
+
+static void particle_to_droplet_class_init (GtsObjectClass * klass)
+{
+  GFS_EVENT_CLASS (klass)->event = gfs_particle_to_droplet_event;
+  klass->read  = gfs_particle_to_droplet_read;
+  klass->write = gfs_particle_to_droplet_write;
+}
+
+GfsEventClass * gfs_particle_to_droplet_class (void)
+{
+  static GfsEventClass * klass = NULL;
+
+  if (klass == NULL) {
+    GtsObjectClassInfo gfs_particle_to_droplet_info = {
+      "GfsParticleToDroplet",
+      sizeof (GfsParticleToDroplet),
+      sizeof (GfsEventClass),
+      (GtsObjectClassInitFunc) particle_to_droplet_class_init,
+      (GtsObjectInitFunc) NULL,
+      (GtsArgSetFunc) NULL,
+      (GtsArgGetFunc) NULL
+    };
+    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_event_class ()),
+                                  &gfs_particle_to_droplet_info);
+  }
+
+  return klass;
+}
+
+/** \endobject{GfsParticleToDroplet} */
+
+/** \beginobject{GfsParticulateField} */
 
 static void voidfraction_from_particles (FttCell * cell, GfsVariable * v, GfsParticulate * part)
 {
hunk ./modules/particulatecommon.c 1722
 
   return klass;
 }
+/** \endobject{GfsParticulateField} */
 
hunk ./modules/particulatecommon.c 1724
-/** \beginobject{GfsFeedParticle} */
+/** \beginobject{GfsSourceParticulate} */
 
hunk ./modules/particulatecommon.c 1726
-static void add_particulate (GfsDomain * domain, 
-			     GfsFeedParticle * feedp, GfsParticleList * plist)
+static gdouble source_particulate_value(GfsSourceGeneric * s, 
+                                           FttCell * cell,
+                                           GfsVariable * v) 
 {
hunk ./modules/particulatecommon.c 1730
-  GfsSimulation * sim = gfs_object_simulation (plist); 
-  GfsEventList * l = GFS_EVENT_LIST (plist); 
-  guint c;
-  FttVector pos,vel;
+
+  GfsSourceParticulate *sp = GFS_SOURCE_PARTICULATE(s);
+  
+  FttCellFace f;
+  f.cell = cell;
+
+  FttCellNeighbors n;
+  ftt_cell_neighbors (cell, &n); 
+
+  switch(v->component){
+  case FTT_X: 
+    f.d = FTT_RIGHT;
+    f.neighbor = n.c[f.d];
+    break;
+  case FTT_Y: 
+    f.d = FTT_TOP;
+    f.neighbor = n.c[f.d];
+    break;
+#if !FTT_2D
+  case FTT_Z: 
+    f.d = FTT_FRONT;
+    f.neighbor = n.c[f.d];
+    break;
+#endif
+  default: g_assert_not_reached ();
+  }
+
+  if(sp->u[v->component]!=NULL)
+    return  gfs_face_interpolated_value(&f, (sp->u[v->component])->i);
+  else 
+    g_assert_not_reached ();
+
+}
+
+static gdouble source_particulate_centered_value(GfsSourceGeneric * s,
+                                                FttCell * cell,
+                                                GfsVariable * v)
+{
+
+  GfsSourceParticulate *sp = GFS_SOURCE_PARTICULATE(s);
+
+  if(sp->u[v->component]!=NULL)
+    return GFS_VALUE(cell,sp->u[v->component]);
+  else
+    g_assert_not_reached ();
+
+}
+
+
+static void source_particulate_destroy (GtsObject * o)
+{
+  gts_object_destroy (GTS_OBJECT (GFS_SOURCE_PARTICULATE (o)->kernel_function));
+
+  (* GTS_OBJECT_CLASS (gfs_source_particulate_class ())->parent_class->destroy) (o); 
+}
+
+void distance_normalization (FttVector * pos1, GfsParticulate * p)
+{
+  gdouble rb = pow (3.*p->volume/(4.*M_PI), 1./3.);
+  FttVector * pos2 = &(GFS_PARTICLE (p)->pos);
+  pos1->x = (pos1->x - pos2->x)/rb;
+  pos1->y = (pos1->y - pos2->y)/rb;
+  pos1->z = 0.;
+#if !FTT_2D
+  pos1->z = (pos1->z - pos2->z)/rb;
+#endif
+}
+
+typedef struct {
+  gdouble correction,volume;
+  GfsParticulate * p;
+  GfsFunction * kernel_function;
+  GfsVariable **v;
+} KernelData;
+
+static void kernel_volume (FttCell * cell, KernelData * kd)
+{
+  gdouble cellvol = gfs_cell_volume (cell,GFS_DOMAIN(gfs_object_simulation(kd->p)));
+
+  kd->volume += cellvol;
+
+  /* correction term to make a discretely conservative kernel */
+  FttVector pos;
+  ftt_cell_pos (cell, &pos);
+  distance_normalization (&pos, kd->p);
+  kd->correction += gfs_function_spatial_value (kd->kernel_function, &pos)*cellvol;
+}
+
+typedef struct {
+  FttVector * pos;
+  gdouble distance; 
+} CondData;
+
+static gboolean cond_kernel (FttCell * cell, gpointer data)
+{
+  CondData * p = data;
+  FttVector pos;
+  ftt_cell_pos (cell, &pos);
+  gdouble radeq;
+  gdouble size = ftt_cell_size (cell)/2.;
+
+#if FTT_2D
+  radeq = size*sqrt(2.);
+#else
+  radeq = size*sqrt(3.);
+#endif /* 3D */
+
+  if (ftt_vector_distance (&pos, p->pos) - radeq <= p->distance) 
+    return TRUE;
+
+  /* Check also if the bubble is inside the cell*/
+  if (p->pos->x > pos.x + size || p->pos->x < pos.x - size ||
+      p->pos->y > pos.y + size || p->pos->y < pos.y - size 
+#if !FTT_2D
+      || p->pos->z > pos.z + size || p->pos->z < pos.z - size 
+#endif
+     )
+    return FALSE;
+
+  return TRUE;
+}
+
+static void diffuse_force (FttCell * cell, KernelData * kd)
+{
+  FttVector pos;
+  FttComponent c;
+  ftt_cell_pos (cell, &pos);
+  distance_normalization (&pos, kd->p);
+
+  GfsSimulation * sim = gfs_object_simulation(kd->p);
+  gdouble liq_rho = sim->physical_params.alpha ? 1./
+    gfs_function_value (sim->physical_params.alpha, cell) : 1.;
+
+  for (c = 0; c <  FTT_DIMENSION; c++) {
+    GFS_VALUE (cell, kd->v[c]) -= (&(kd->p->force.x))[c]/liq_rho*
+      gfs_function_spatial_value (kd->kernel_function, &pos)/kd->correction;
+  }
+}
+
+static gboolean source_particulate_event (GfsEvent * event, 
+    GfsSimulation * sim) 
+{
+  if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_source_particulate_class ())->parent_class)->event)
+      (event, sim)) {
+    GfsDomain * domain = GFS_DOMAIN (sim);
+    GfsSourceParticulate * sp = GFS_SOURCE_PARTICULATE (event);
+    gdouble influencerad;
+
+    FttComponent c;
+
+    /* Reset variable */
+    for (c = 0; c <  FTT_DIMENSION; c++) 
+      gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+          (FttCellTraverseFunc) gfs_cell_reset, sp->u[c]);
+
+    /* Loop over the list of particles in the selected object */
+    GSList * i = GFS_EVENT_LIST (sp->plist)->list->items;
+    while (i) {
+      influencerad = pow (GFS_PARTICULATE(i->data)->volume*3./(4.*M_PI), 1./3.)*sp->rkernel;
+      CondData cd = { &GFS_PARTICLE (i->data)->pos, sp->rkernel };
+      KernelData kd = { 0., 0., GFS_PARTICULATE(i->data), sp->kernel_function,sp->u};
+      gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+          (FttCellTraverseFunc) kernel_volume, &kd,
+          cond_kernel, &cd);          
+      kd.correction /= kd.volume;
+      gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+          (FttCellTraverseFunc) diffuse_force, &kd,
+          cond_kernel, &cd);
+
+      i = i->next;
+    }
+
+
+    return TRUE;
+  }
+  return FALSE;
+}
+
+static void source_particulate_read (GtsObject ** o, GtsFile * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_source_particulate_class ())->parent_class->read) (o, fp); 
+  if (fp->type == GTS_ERROR)
+    return;
+
+  if (fp->type != GTS_STRING) {
+    gts_file_error (fp, "expecting a string (object name)");
+    return;
+  }
+  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (*o));
+  GfsSourceParticulate * sp = GFS_SOURCE_PARTICULATE (*o);
+  GtsObject * object = gfs_object_from_name (domain, fp->token->str);
+  if (object == NULL) {
+    gts_file_error (fp, "unknown object '%s'", fp->token->str);
+    return;
+  }
+  if (!GFS_IS_PARTICLE_LIST (object)) {
+    gts_file_error (fp, "object '%s' is not a GfsParticleList", fp->token->str);
+    return;  
+  }
+  gts_file_next_token (fp);
   
hunk ./modules/particulatecommon.c 1931
-  pos.x = gfs_function_value (feedp->posx, NULL); 
-  pos.y = gfs_function_value (feedp->posy, NULL); 
-  pos.z = gfs_function_value (feedp->posz, NULL); 
-  FttCell * cell = gfs_domain_locate (domain, pos, -1, NULL);    
+  sp->plist = GFS_PARTICLE_LIST (object);
+
+  if (fp->type != '{') {
+    gts_file_error (fp, "expecting an opening brace");
+    return;
+  }
+  fp->scope_max++;
+  gts_file_next_token (fp);
+
+  while (fp->type != GTS_ERROR && fp->type != '}') {
+    if (fp->type == '\n') {
+      gts_file_next_token (fp);
+      continue;
+    }
+    if (fp->type != GTS_STRING) {
+      gts_file_error (fp, "expecting a keyword");
+      return;
+    }  
+    else if (!strcmp (fp->token->str, "rkernel")) {
+      gts_file_next_token (fp);
+      if (fp->type != '=') {
+	gts_file_error (fp, "expecting '='");
+	return;
+      }    
+      gts_file_next_token (fp);
+      sp->rkernel = atof (fp->token->str);
+      gts_file_next_token (fp);
+    }
+    else if (!strcmp (fp->token->str, "kernel")) {
+      gts_file_next_token (fp);
+      if (fp->type != '=') {
+	gts_file_error (fp, "expecting '='");
+	return;
+      }
+      gts_file_next_token (fp);
+      gfs_function_read (sp->kernel_function, gfs_object_simulation (*o), fp);
+    }
+    else {
+      gts_file_error (fp, "unknown keyword `%s'", fp->token->str);
+      return;
+    }
+  }
+  if (fp->type == GTS_ERROR)
+    return;
+  if (fp->type != '}') {
+    gts_file_error (fp, "expecting a closing brace");
+    return;
+  }
+  fp->scope_max--;
+  gts_file_next_token (fp);
+
+  /* force variable declaration*/
+  sp->u[0] = gfs_domain_get_or_add_variable (domain, g_strconcat(GFS_EVENT(sp->plist)->name,"_Fx", NULL), "Fx-component of the source particulate");
+  sp->u[1] = gfs_domain_get_or_add_variable (domain, g_strconcat(GFS_EVENT(sp->plist)->name,"_Fy", NULL), "Fy-component of the source particulate");
+
+#if !FTT_2D
+  sp->u[2] = gfs_domain_get_or_add_variable (domain, g_strconcat(GFS_EVENT(sp->plist)->name,"_Fz", NULL), "Fz-component of the source particulate");
+#endif
+
+}
+
+static void source_particulate_write (GtsObject * o, FILE * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_source_particulate_class ())->parent_class->write) (o, fp); 
+  
+  GfsSourceParticulate * sp = GFS_SOURCE_PARTICULATE (o);
+
+  fprintf (fp, " %s", GFS_EVENT (GFS_SOURCE_PARTICULATE (o)->plist)->name);
+  fprintf (fp, " { rkernel = %g ", sp->rkernel);
+  fputs (" kernel =", fp);
+  gfs_function_write (GFS_SOURCE_PARTICULATE (o)->kernel_function, fp);
+  fputc ('}', fp);
+
+}
+
+static void source_particulate_class_init (GtsObjectClass * klass)
+{
+  GFS_EVENT_CLASS (klass)->event = source_particulate_event;
+  klass->destroy =  source_particulate_destroy;
+  klass->read    =  source_particulate_read;
+  klass->write   =  source_particulate_write;
+}
+
+static void source_particulate_init (GfsSourceParticulate * sp )
+{
+  sp->kernel_function = gfs_function_new (gfs_function_spatial_class (), 0.);
+  GfsSourceGeneric * s = GFS_SOURCE_GENERIC (sp);
+  s->mac_value = source_particulate_value;
+  s->centered_value = source_particulate_centered_value;
+  s->flux = NULL;
+}
+
+GfsSourceGenericClass * gfs_source_particulate_class (void)
+{
+  static GfsSourceGenericClass * klass = NULL;
+
+  if (klass == NULL) {
+    GtsObjectClassInfo gfs_source_particulate_info = {
+      "GfsSourceParticulate",
+      sizeof (GfsSourceParticulate),
+      sizeof (GfsSourceGenericClass),
+      (GtsObjectClassInitFunc) source_particulate_class_init,
+      (GtsObjectInitFunc) source_particulate_init,
+      (GtsArgSetFunc) NULL,
+      (GtsArgGetFunc) NULL
+    };
+    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_source_velocity_class ()),
+                                  &gfs_source_particulate_info);
+  }
+
+  return klass;
+}
+/** \endobject{GfsSourceParticulate} */
+
+
+/** \beginobject{GfsFeedParticle} */
+
+static void feed_particulate (GfsDomain * domain, 
+			     GfsFeedParticle * feedp)
+{
+  GfsParticulate newpart; 
+  newpart.parent.pos.x = gfs_function_value (feedp->posx, NULL); 
+  newpart.parent.pos.y = gfs_function_value (feedp->posy, NULL); 
+  newpart.parent.pos.z = gfs_function_value (feedp->posz, NULL); 
+
+  FttCell * cell = gfs_domain_locate (domain, newpart.parent.pos, -1, NULL);    
   if (cell) {
hunk ./modules/particulatecommon.c 2058
-    /* Construct an Object */
-    GtsObjectClass * klass = l->klass;
-    g_assert (klass);
-    GtsObject * object = gts_object_new (klass);
-    gfs_object_simulation_set (object, sim);
-    l->list->items = g_slist_reverse (l->list->items);	
-    gts_container_add (GTS_CONTAINER (l->list), GTS_CONTAINEE (object));
-    l->list->items = g_slist_reverse (l->list->items);
-    GfsEvent * list = GFS_EVENT (l);	
-    gfs_event_set (GFS_EVENT (object), 
-                   list->start, list->end, list->step, list->istart, list->iend, list->istep);
-    GfsParticulate * part = GFS_PARTICULATE (object);
-    GfsParticle * p = GFS_PARTICLE (part);
-    
-    vel.x = gfs_function_value (feedp->velx, cell);
-    vel.y = gfs_function_value (feedp->vely, cell);
-    vel.z = gfs_function_value (feedp->velz, cell);
-    part->vel = vel;
-    p->pos = pos;
-    part->volume = gfs_function_value (feedp->vol, cell);
-    p->id = ++plist->idlast;
-    part->mass = gfs_function_value (feedp->mass, cell);
-    for (c = 0; c < FTT_DIMENSION; c++)
-      (&part->force.x)[c] = 0.;
-    assign_forces ( part , plist->forces);
+    newpart.vel.x  = gfs_function_value (feedp->velx, cell);
+    newpart.vel.y  = gfs_function_value (feedp->vely, cell);
+    newpart.vel.z  = gfs_function_value (feedp->velz, cell);
+    newpart.volume = gfs_function_value (feedp->vol, cell);
+    newpart.mass = gfs_function_value (feedp->mass, cell);
+    add_particulate (newpart,feedp->plist);
   }       
 }
 
hunk ./modules/particulatecommon.c 2072
   if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_feed_particle_class ())->parent_class)->event)
       (event, sim)) {  
     GfsDomain * domain = GFS_DOMAIN (sim);
-    GfsParticleList * plist = GFS_PARTICLE_LIST (event);
     GfsFeedParticle * feedp = GFS_FEED_PARTICLE (event);
     gint i;
     guint np = gfs_function_value (feedp->np, NULL);
hunk ./modules/particulatecommon.c 2077
 
     for (i = 0; i < np; i++)
-      add_particulate (domain, feedp, plist);
+      feed_particulate (domain, feedp);
     return TRUE;
   }
   return FALSE;
hunk ./modules/particulatecommon.c 2107
 
   GfsFeedParticle * feedp = GFS_FEED_PARTICLE(*o);
 
+  if (fp->type != GTS_STRING) {
+    gts_file_error (fp, "expecting a string (object name)");
+    return;
+  }
+
+  GtsObject * object = gfs_object_from_name (GFS_DOMAIN (gfs_object_simulation (*o)), 
+					     fp->token->str);
+  if (object == NULL) {
+    gts_file_error (fp, "unknown object '%s'", fp->token->str);
+    return;
+  }
+  if (!GFS_IS_PARTICLE_LIST (object)) {
+    gts_file_error (fp, "object '%s' is not a GfsParticleList", fp->token->str);
+    return;  
+  }
+  gts_file_next_token (fp);
+  
+  feedp->plist = GFS_PARTICLE_LIST (object);
+
+
   if (fp->type != '{') {
     gts_file_error (fp, "expecting an opening brace");
     return;
hunk ./modules/particulatecommon.c 2245
   (* GTS_OBJECT_CLASS (gfs_feed_particle_class ())->parent_class->write) (o, fp);
 
   GfsFeedParticle * feedp = GFS_FEED_PARTICLE(o);
+
+  fprintf (fp, " %s", GFS_EVENT (feedp->plist)->name); 
+
   fputs (" {\n  nparts = ", fp);
   gfs_function_write (feedp->np, fp);
   fputs ("  xfeed =", fp);
hunk ./modules/particulatecommon.c 2279
 
 static void gfs_feed_particle_init ( GfsFeedParticle * feedp)
 {
-  feedp->np   = gfs_function_new (gfs_function_class (), 0.);
+  feedp->np   = gfs_function_new (gfs_function_class (), 1);
   feedp->posx = gfs_function_new (gfs_function_class (), 0.);
   feedp->posy = gfs_function_new (gfs_function_class (), 0.);
   feedp->posz = gfs_function_new (gfs_function_class (), 0.);
hunk ./modules/particulatecommon.c 2304
       (GtsArgSetFunc) NULL,
       (GtsArgGetFunc) NULL
     };
-    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_particle_list_class ()),
+    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_event_class ()),
 				  &gfs_feed_particle_info);
   }
   return klass;
hunk ./modules/particulatecommon.c 2311
 }
 
 /** \endobject{GfsFeedParticle} */
+
+/* /\* feed particle 2 test case *\/ */
+
+/* static void feed_particulate2 (GfsDomain * domain,  */
+/* 			     GfsFeedParticle2 * feedp) */
+/* { */
+/*   GfsParticulate newpart;  */
+/*   newpart.parent.pos.x = gfs_function_value (feedp->posx, NULL);  */
+/*   newpart.parent.pos.y = gfs_function_value (feedp->posy, NULL);  */
+/*   newpart.parent.pos.z = gfs_function_value (feedp->posz, NULL);  */
+
+/*   FttCell * cell = gfs_domain_locate (domain, newpart.parent.pos, -1, NULL);     */
+/*   if (cell) { */
+/*     newpart.vel.x  = gfs_function_value (feedp->velx, cell); */
+/*     newpart.vel.y  = gfs_function_value (feedp->vely, cell); */
+/*     newpart.vel.z  = gfs_function_value (feedp->velz, cell); */
+/*     newpart.volume = gfs_function_value (feedp->vol, cell); */
+/*     newpart.mass = gfs_function_value (feedp->mass, cell); */
+/*     add_particulate (newpart,feedp->plist); */
+/*   }        */
+/* } */
+
+/* static gboolean gfs_feed_particle2_event (GfsEvent * event, GfsSimulation * sim) */
+/* {  */
+/*   if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_feed_particle2_class ())->parent_class)->event) */
+/*       (event, sim)) {   */
+/*     GfsDomain * domain = GFS_DOMAIN (sim); */
+/*     GfsFeedParticle2 * feedp = GFS_FEED_PARTICLE2 (event); */
+/*     gint i; */
+/*     guint np = gfs_function_value (feedp->np, NULL); */
+
+/*     for (i = 0; i < np; i++) */
+/*       feed_particulate2 (domain, feedp); */
+/*     return TRUE; */
+/*   } */
+/*   return FALSE; */
+/* } */
+
+/* static void gfs_feed_particle2_destroy (GtsObject * o) */
+/* { */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->np)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->posx)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->posy)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->posz)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->velx)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->vely)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->velz)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->mass)); */
+/*   gts_object_destroy (GTS_OBJECT (GFS_FEED_PARTICLE2 (o)->vol)); */
+
+/*   (* GTS_OBJECT_CLASS (gfs_feed_particle2_class ())->parent_class->destroy) (o);  */
+/* } */
+
+/* static void gfs_feed_particle2_read (GtsObject ** o, GtsFile * fp) */
+/* {   */
+/*   if (GTS_OBJECT_CLASS (gfs_feed_particle2_class ())->parent_class->read) */
+/*     (* GTS_OBJECT_CLASS (gfs_feed_particle2_class ())->parent_class->read) (o, fp); */
+/*   if (fp->type == GTS_ERROR) */
+/*     return; */
+
+/*   GfsFeedParticle2 * feedp = GFS_FEED_PARTICLE2(*o); */
+
+/*   if (fp->type != GTS_STRING) { */
+/*     gts_file_error (fp, "expecting a string (object name)"); */
+/*     return; */
+/*   } */
+
+/*   GtsObject * object = gfs_object_from_name (GFS_DOMAIN (gfs_object_simulation (*o)),  */
+/* 					     fp->token->str); */
+/*   if (object == NULL) { */
+/*     gts_file_error (fp, "unknown object '%s'", fp->token->str); */
+/*     return; */
+/*   } */
+/*   if (!GFS_IS_PARTICLE_LIST (object)) { */
+/*     gts_file_error (fp, "object '%s' is not a GfsParticleList", fp->token->str); */
+/*     return;   */
+/*   } */
+/*   gts_file_next_token (fp); */
+  
+/*   feedp->plist = GFS_PARTICLE_LIST (object); */
+
+
+/*   if (fp->type != '{') { */
+/*     gts_file_error (fp, "expecting an opening brace"); */
+/*     return; */
+/*   } */
+/*   fp->scope_max++; */
+/*   gts_file_next_token (fp); */
+
+/*   while (fp->type != GTS_ERROR && fp->type != '}') { */
+/*     if (fp->type == '\n') { */
+/*       gts_file_next_token (fp); */
+/*       continue; */
+/*     } */
+/*       if (fp->type != GTS_STRING) { */
+/*       gts_file_error (fp, "expecting a keyword"); */
+/*       return; */
+/*     }   */
+/*   else if (!strcmp (fp->token->str, "nparts")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       }     */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->np, gfs_object_simulation (*o), fp);     */
+/*     } */
+/* else if (!strcmp (fp->token->str, "condition")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       }     */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->condition, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "xfeed")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->posx, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "yfeed")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->posy, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "zfeed")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->posz, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "velx")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->velx, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "vely")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->vely, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "velz")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->velz, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "mass")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->mass, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else if (!strcmp (fp->token->str, "volume")) { */
+/*       gts_file_next_token (fp); */
+/*       if (fp->type != '=') { */
+/*         gts_file_error (fp, "expecting '='"); */
+/*         return; */
+/*       } */
+/*       gts_file_next_token (fp); */
+/*       gfs_function_read (feedp->vol, gfs_object_simulation (*o), fp);     */
+/*     } */
+/*     else { */
+/*       gts_file_error (fp, "unknown keyword `%s'", fp->token->str); */
+/*       return; */
+/*     } */
+/*   } */
+/*   if (fp->type == GTS_ERROR) */
+/*     return; */
+/*   if (fp->type != '}') { */
+/*     gts_file_error (fp, "expecting a closing brace"); */
+/*     return; */
+/*   } */
+/*   fp->scope_max--; */
+/*   gts_file_next_token (fp); */
+
+/* } */
+
+/* static void gfs_feed_particle2_write (GtsObject * o, FILE * fp) */
+/* { */
+/*   (* GTS_OBJECT_CLASS (gfs_feed_particle2_class ())->parent_class->write) (o, fp); */
+
+/*   GfsFeedParticle2 * feedp = GFS_FEED_PARTICLE2(o); */
+
+/*   fprintf (fp, " %s", GFS_EVENT (feedp->plist)->name);  */
+
+/*   fputs (" {\n  nparts = ", fp); */
+/*   gfs_function_write (feedp->np, fp); */
+/*   fputs ("  xfeed =", fp); */
+/*   gfs_function_write (feedp->posx, fp); */
+/*   fputs (" yfeed =", fp); */
+/*   gfs_function_write (feedp->posy, fp); */
+/*   fputs (" zfeed =", fp); */
+/*   gfs_function_write (feedp->posz, fp); */
+/*   fputs ("\n  velx =", fp); */
+/*   gfs_function_write (feedp->velx, fp); */
+/*   fputs (" vely =", fp); */
+/*   gfs_function_write (feedp->vely, fp); */
+/*   fputs (" velz =", fp); */
+/*   gfs_function_write (feedp->velz, fp); */
+/*   fputs ("\n  mass =", fp); */
+/*   gfs_function_write (feedp->mass, fp); */
+/*   fputs ("\n  volume =", fp); */
+/*   gfs_function_write (feedp->vol, fp); */
+/*   fputs ("\n}", fp); */
+/* } */
+
+/* static void gfs_feed_particle2_class_init (GfsEventClass * klass) */
+/* { */
+/*   GFS_EVENT_CLASS (klass)->event    = gfs_feed_particle2_event; */
+/*   GTS_OBJECT_CLASS (klass)->destroy = gfs_feed_particle2_destroy; */
+/*   GTS_OBJECT_CLASS (klass)->read    = gfs_feed_particle2_read; */
+/*   GTS_OBJECT_CLASS (klass)->write   = gfs_feed_particle2_write;   */
+/* } */
+
+/* static void gfs_feed_particle2_init ( GfsFeedParticle2 * feedp) */
+/* { */
+/*   feedp->np   = gfs_function_new (gfs_function_class (), 1); */
+/*   feedp->posx = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->posy = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->posz = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->velx = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->vely = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->velz = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->mass = gfs_function_new (gfs_function_class (), 0.); */
+/*   feedp->vol  = gfs_function_new (gfs_function_class (), 0.); */
+/* } */
+
+/* GfsEventClass * gfs_feed_particle2_class (void) */
+/* { */
+/*   static GfsEventClass * klass = NULL; */
+
+/*   if (klass == NULL) { */
+/*     GtsObjectClassInfo gfs_feed_particle2_info = { */
+/*       "GfsFeedParticle2", */
+/*       sizeof (GfsFeedParticle2), */
+/*       sizeof (GfsEventClass), */
+/*       (GtsObjectClassInitFunc) gfs_feed_particle2_class_init, */
+/*       (GtsObjectInitFunc) gfs_feed_particle2_init, */
+/*       (GtsArgSetFunc) NULL, */
+/*       (GtsArgGetFunc) NULL */
+/*     }; */
+/*     klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_event_class ()), */
+/* 				  &gfs_feed_particle2_info); */
+/*   } */
+/*   return klass; */
+/* } */
+
+/** \endobject{GfsFeedParticle2} */
+
+/** /beginobject{GfsBcParticle} */
+
+typedef struct {
+  gint boxid;
+  FttDirection d;
+  GfsParticle *p;
+} Particle_send;
+
+/*Checks the intersection of a particle path ray(a line segment) with the boundaries of the containee cell*/
+static gboolean check_intersetion(FttVector cellpos, FttVector p0, FttVector p1, 
+				  FttDirection *dstore, gdouble size)
+{
+
+  gdouble t;
+  FttDirection d;
+
+
+  for(d = 0; d < FTT_NEIGHBORS; d++){
+
+    gdouble normal = ((gdouble) FTT_OPPOSITE_DIRECTION(d) - (gdouble)d);
+
+#if FTT_2D
+    switch(d/2){
+    case 0:
+      if((p1.x - p0.x)!=0 && normal*(p1.x-p0.x) > 0){
+	t = (cellpos.x + normal*size*0.5 - p0.x)/(p1.x - p0.x);	
+	gdouble py = p0.y + t*(p1.y - p0.y);
+	if((py - cellpos.y + size*0.5)*(py - cellpos.y - size*0.5) <= 0  &&  t*(t-1)<= 0 ){
+	  *dstore = d;
+	  return TRUE;
+	}
+      }
+      break;
+    case 1:
+      if((p1.y - p0.y)!=0 && normal*(p1.y-p0.y) > 0){
+	t = (cellpos.y + normal*size*0.5- p0.y)/(p1.y - p0.y);
+	
+	gdouble px = p0.x + t*(p1.x - p0.x);	
+	if((px - cellpos.x + size*0.5)*(px - cellpos.x - size*0.5) <= 0  &&  t*(t-1) <= 0){
+	  *dstore = d;
+	  return TRUE;
+	}
+      }
+      break;
+    default: g_assert_not_reached();
+    }
+#else 
+    switch(d/2){
+    case 0:
+      if((p1.x - p0.x)!=0 && normal*(p1.x-p0.x) > 0){
+	t = (cellpos.x + normal*size*0.5 - p0.x)/(p1.x - p0.x);	
+	gdouble py = p0.y + t*(p1.y - p0.y);
+	gdouble pz = p0.z + t*(p1.z - p0.z);	
+	if((py - cellpos.y + size*0.5)*(py - cellpos.y - size*0.5) <= 0  && 
+	   (pz - cellpos.z + size*0.5)*(pz - cellpos.z - size*0.5) <= 0
+	   &&  t*(t-1)<= 0 )
+	  {	  
+	  *dstore = d;
+	  return TRUE;
+	}
+      }
+      break;
+    case 1:
+      if((p1.y - p0.y)!=0 && normal*(p1.y-p0.y) > 0){
+	t = (cellpos.y + normal*size*0.5- p0.y)/(p1.y - p0.y);
+	
+	gdouble px = p0.x + t*(p1.x - p0.x);
+	gdouble pz = p0.z + t*(p1.z - p0.z);	
+	if((px - cellpos.x + size*0.5)*(px - cellpos.x - size*0.5) <= 0  && 
+	   (pz - cellpos.z + size*0.5)*(pz - cellpos.z - size*0.5) <= 0
+	   &&  t*(t-1)<= 0 )
+	  {	  
+	  *dstore = d;
+	  return TRUE;
+	}	
+      }
+      break;
+    case 2:
+      if((p1.z - p0.z)!=0 && normal*(p1.z-p0.z) > 0){
+	t = (cellpos.z + normal*size*0.5- p0.z)/(p1.z - p0.z);
+	
+	gdouble px = p0.x + t*(p1.x - p0.x);
+	gdouble py = p0.y + t*(p1.y - p0.y);	
+	if((px - cellpos.x + size*0.5)*(px - cellpos.x - size*0.5) <= 0  && 
+	   (py - cellpos.y + size*0.5)*(py - cellpos.y - size*0.5) <= 0
+	   &&  t*(t-1)<= 0 )
+	  {	  
+	  *dstore = d;
+	  return TRUE;
+	}	
+      }
+      break;
+    default: g_assert_not_reached();
+    }
+#endif
+  }
+
+  g_warning("Intersection finding algorithm failed\n");
+  return FALSE;
+}
+
+/*Tracks the particle path ray to identify boundary cell for the application of the Boundary Conditions*/
+static FttCell * boundarycell (GfsDomain *domain, GfsParticle *p, FttDirection *dstore)
+{
+ 
+  FttCell * cell = gfs_domain_locate(domain, p->pos_old, -1, NULL);
+  g_assert(cell!=NULL);
+
+  FttVector cellpos;
+  gdouble size;
+  ftt_cell_pos(cell, &cellpos);
+  size = ftt_cell_size(cell); 
+  check_intersetion(cellpos, p->pos_old, p->pos, dstore, size);    
+  FttCellFace face = ftt_cell_face(cell, *dstore);
+ 
+  if(!face.neighbor)
+    return cell;
+
+  while(!GFS_CELL_IS_BOUNDARY(face.neighbor)) {    
+    cell = face.neighbor;
+    g_assert(cell!=NULL);
+    ftt_cell_pos(cell, &cellpos);
+    size = ftt_cell_size(cell);  
+    check_intersetion(cellpos, p->pos_old, p->pos, dstore, size);
+    face = ftt_cell_face(cell, *dstore);
+ 
+    if(!face.neighbor)
+      return cell;
+  };
+    
+  if(cell)
+    return cell;
+  else
+    g_assert_not_reached();
+
+}
+
+/*Periodic boundary conditions*/
+static void periodic_bc_particle(FttDirection d, GfsBox * box, GSList *particles, GfsBcParticle *bc)
+{
+  FttVector box_face, box_face_nbr;
+  GfsBox *box_nbr = GFS_BOX(GFS_BOUNDARY_PERIODIC(box->neighbor[d])->matching);
+  g_assert(box->root!=NULL);
+  g_assert(box_nbr->root!=NULL);
+  ftt_cell_pos(box->root, &box_face);
+  ftt_cell_pos(box_nbr->root, &box_face_nbr);
+  gdouble size = ftt_cell_size(box->root);
+
+  gdouble normal = (gdouble)FTT_OPPOSITE_DIRECTION(d) - (gdouble) d;
+  (&box_face.x)[d/2] += (gdouble)normal * size/2.;
+  (&box_face_nbr.x)[d/2] -= (gdouble)normal * size/2.;
+
+  GSList *i = particles;
+  gdouble tolerance = size/1.e8;
+  while(i){
+      GfsParticle *p = (GfsParticle *) (i->data);
+      i = i->next;
+      gdouble distance = ((&p->pos.x)[d/2] - (&box_face.x)[d/2])*normal;     
+      (&p->pos.x)[d/2] = (&box_face_nbr.x)[d/2] + distance + normal*tolerance;
+      (&p->pos_old.x)[d/2] = (&p->pos.x)[d/2];
+      particles = g_slist_remove(particles,p);
+      gts_container_add(GTS_CONTAINER(GFS_EVENT_LIST(bc->plist)->list),GTS_CONTAINEE(p));     
+  } 
+}
+
+#ifdef HAVE_MPI
+/*MPI Boundary conditions*/
+static void mpi_send_particle(gint dest, GSList *particles)
+{
+  GfsRequest * request = gfs_send_objects(particles, dest);
+  gfs_wait(request);
+}
+
+static void mpi_rcv_particle(gint src, GfsParticleList *plist)
+{
+  GfsSimulation *sim = gfs_object_simulation(plist);
+  GfsDomain *domain = GFS_DOMAIN(sim);
+  GfsEventList *l = GFS_EVENT_LIST(plist);
+
+  GSList *list = gfs_receive_particles (domain, src,l);
+  while(list){
+    GtsObject * object = (GtsObject *)(list->data);
+    GfsEvent * event = GFS_EVENT (l);
+    gfs_event_set (GFS_EVENT (object),
+		   event->start, event->end, event->step, event->istart, event->iend, event->istep);
+    gts_container_add(GTS_CONTAINER(l->list),GTS_CONTAINEE(object));
+    if(GFS_IS_PARTICULATE(object))
+      GFS_PARTICULATE(object)->forces = plist->forces;
+    list = list->next;
+  }
+
+  g_slist_free(list);
+}
+
+#endif /*HAVE_MPI*/
+
+static void send_particles(FttDirection d, GfsBoundary *b, GfsBox *box, gint nsends, 
+			   GSList *particles, GfsBcParticle *bc)
+{
+#ifdef HAVE_MPI
+  GfsBoundaryMpi *mpi = GFS_BOUNDARY_MPI (b);
+  if(GFS_IS_BOUNDARY_MPI(mpi)){
+    /*MPI BC*/
+    mpi_send_particle(mpi->process, particles);   
+    return;
+  }
+#endif /*HAVE_MPI*/
+  if(nsends > 0){
+    if(box->neighbor[d] && GFS_IS_BOUNDARY_PERIODIC(box->neighbor[d])){
+      /*Periodic BC*/    
+      g_assert(GFS_IS_BOX(GFS_BOUNDARY(box->neighbor[d])->box));     
+      periodic_bc_particle(d, box, particles, bc);
+    } 
+  }  
+}
+
+static void rcv_particles(GfsBoundary *b, GfsParticleList *plist )
+{
+#ifdef HAVE_MPI
+  GfsBoundaryMpi *mpi = GFS_BOUNDARY_MPI (b);
+  if(GFS_IS_BOUNDARY_MPI(mpi)){
+    /*MPI BC*/
+    mpi_rcv_particle(mpi->process, plist);    
+  } 
+#endif /*HAVE_MPI*/
+}
+
+static void box_send_bc(GfsBox *box, GfsBcParticle *bc)
+{
+
+  gint nsends[FTT_NEIGHBORS];
+  GSList *packet_send[FTT_NEIGHBORS];
+  FttDirection d;
+
+  for (d = 0; d < FTT_NEIGHBORS; d++){
+    nsends[d] = 0;  
+    packet_send[d] = NULL;
+  }
+
+
+  GSList * i = bc->boundary;
+  while(i){  
+    Particle_send *psend = (Particle_send *) (i->data);   
+    i = i->next;    
+    if(psend->boxid == box->id){  
+      nsends[psend->d]++;
+      packet_send[psend->d] = g_slist_append(packet_send[psend->d], psend->p);
+      bc->boundary = g_slist_remove(bc->boundary,psend);
+      g_free(psend);
+    }
+  }
+ 
+  for (d = 0; d < FTT_NEIGHBORS; d++){    
+    /*Fixme: If neighboring box does not exist -> slip-wall (Reflect)*/
+    if(GFS_IS_BOUNDARY(box->neighbor[d])){	
+      GfsBoundary *b = GFS_BOUNDARY(box->neighbor[d]);        
+      send_particles(d, b, box, nsends[d], packet_send[d], bc);     
+    }
+  }  
+ 
+}
+
+static void box_rcv_bc(GfsBox *box, GfsBcParticle *bc)
+{
+  FttDirection d;
+
+  for (d = 0; d < FTT_NEIGHBORS; d++){
+    if(box->neighbor[d] && GFS_IS_BOUNDARY(box->neighbor[d])){
+      GfsBoundary *b = GFS_BOUNDARY(box->neighbor[d]);
+      rcv_particles(b, bc->plist);
+    }
+  }
+}
+
+static void list_boundary_particles(GfsEvent * event, GfsBcParticle *bc)
+{
+ 
+  GfsSimulation *sim = gfs_object_simulation(bc->plist);
+  GfsDomain *domain = GFS_DOMAIN(sim);
+
+  GfsParticle *p = GFS_PARTICLE(event);
+  FttCell * cellp = gfs_domain_locate(domain, p->pos, -1, NULL);
+  if(cellp==NULL){
+    gts_container_remove(GTS_CONTAINER(GFS_EVENT_LIST(bc->plist)->list),GTS_CONTAINEE(event)); 
+    FttDirection d;   
+    FttCell *cell = boundarycell (domain, p, &d);
+    if(cell){
+      while(!FTT_CELL_IS_ROOT(cell))
+	cell = ftt_cell_parent(cell);
+      
+      GfsBox *box = GFS_BOX(FTT_ROOT_CELL(cell)->parent);
+      
+      if(d < 0 || d > FTT_NEIGHBORS)
+	g_assert_not_reached();
+      
+      if(!box->neighbor[d] || GFS_IS_BOUNDARY(box->neighbor[d])){
+      	Particle_send *psend = g_malloc(sizeof(Particle_send));      
+	psend->boxid = box->id;
+	psend->d = d;
+	psend->p = p;      
+	bc->boundary = g_slist_append(bc->boundary, psend);
+      }   
+    } 
+    else
+      gts_object_destroy(GTS_OBJECT(event));    
+  }
+  
+}
+
+static void free_boundary_particles(GfsBcParticle *bc)
+{
+  GSList *i = bc->boundary;
+
+  while(i){
+    Particle_send *psend = (Particle_send *) (i->data);
+    i = i->next;
+    bc->boundary = g_slist_remove(bc->boundary,psend);
+    g_free(psend);
+  }
+  g_free(bc->boundary);
+}
+
+
+static void gfs_particle_bc (GfsParticleList *plist) 
+{
+    GfsEventList *l = GFS_EVENT_LIST(plist);
+    GfsBcParticle *bc = g_malloc0 (sizeof(GfsBcParticle));
+
+    GfsSimulation *sim = gfs_object_simulation(plist);
+    GfsDomain *domain = GFS_DOMAIN(sim);
+
+    bc->plist = plist;   
+    bc->boundary = NULL;
+    gts_container_foreach (GTS_CONTAINER (l->list), (GtsFunc)list_boundary_particles, bc); 
+    
+    gts_container_foreach (GTS_CONTAINER (domain),
+    			   (GtsFunc) box_send_bc, bc);
+ 
+    gts_container_foreach (GTS_CONTAINER (domain),
+    			   (GtsFunc) box_rcv_bc, bc);
+
+    free_boundary_particles(bc);
+    g_free(bc);       
+}
+
+/** \end gfs_particle_bc */
hunk ./modules/particulatecommon.h 21
  */
 
 #include "particle.h"
+#include "refine.h"
+#include "adaptive.h"
+#include "domain.h"
+#include "fluid.h"
+#include "solid.h"
+#include "vof.h"
+#include "source.h"
 
 /* GfsParticulate: Header */
 
hunk ./modules/particulatecommon.h 55
   GfsEventList parent;
   gint idlast;
   GtsSListContainer * forces;
+  gboolean first_call;
 };
 
 #define GFS_PARTICLE_LIST(obj)            GTS_OBJECT_CAST (obj,		\
hunk ./modules/particulatecommon.h 126
 
 struct _GfsDropletToParticle{
   /*< private >*/
-  GfsParticleList parent;
-  GfsVariable * v;
+  GfsEvent parent;
   
   /*< public >*/
hunk ./modules/particulatecommon.h 129
+  GfsParticleList * plist;
   GfsFunction * fc;
   GfsVariable * c;
   gint min;
hunk ./modules/particulatecommon.h 146
 
 GfsEventClass * gfs_droplet_to_particle_class  (void);
 
+/* GfsParticleToDroplet: header */
+
+typedef struct _GfsParticleToDroplet                GfsParticleToDroplet;
+
+struct _GfsParticleToDroplet {
+  /*< private >*/
+  GfsEvent parent;
+
+  /*< public >*/
+  GfsParticleList * plist;
+  GfsFunction * fc;
+  GfsSurface *shape;
+  gint maxlevel;
+  gdouble resetwith;
+  GfsVariable * c;
+};
+ 
+
+#define GFS_PARTICLE_TO_DROPLET(obj)            GTS_OBJECT_CAST (obj,\
+                                                   GfsParticleToDroplet,\
+                                                   gfs_particle_to_droplet_class ())
+#define GFS_IS_PARTICLE_TO_DROPLET(obj)         (gts_object_is_from_class (obj,\
+                                                   gfs_particle_to_droplet_class ()))
+
+GfsEventClass * gfs_particle_to_droplet_class  (void);
+
+
 /* GfsParticulateField: header */
 
 typedef struct _GfsParticulateField                GfsParticulateField;
hunk ./modules/particulatecommon.h 197
 
 GfsVariableClass * gfs_particulate_field_class  (void);
 
+/* GfsSourceLangrangian: header */
+
+typedef struct _GfsSourceParticulate                GfsSourceParticulate;
+
+struct _GfsSourceParticulate {
+  /*< private >*/
+  GfsSourceVelocity parent;
+  GfsVariable * u[FTT_DIMENSION];
+
+  /*< public >*/
+  GfsParticleList * plist;
+  gdouble rkernel;
+  GfsFunction * kernel_function;
+};
+ 
+
+#define GFS_SOURCE_PARTICULATE(obj)            GTS_OBJECT_CAST (obj,\
+                                                   GfsSourceParticulate,\
+                                                   gfs_source_Particulate_class ())
+#define GFS_IS_SOURCE_PARTICULATE(obj)         (gts_object_is_from_class (obj,\
+                                                   gfs_source_Particulate_class ()))
+
+GfsSourceGenericClass * gfs_source_particulate_class  (void);
+
 /* GfsFeedParticle: header */
 
 typedef struct _GfsFeedParticle GfsFeedParticle;
hunk ./modules/particulatecommon.h 227
 
 struct _GfsFeedParticle{
   /*< private >*/
-  GfsParticleList parent;
-  GfsVariable * v;
+  GfsEvent parent;
   
   /*< public >*/
hunk ./modules/particulatecommon.h 230
+  GfsParticleList * plist;
+  gchar * direction;
+  gint * parray;
   GfsFunction * posx, * posy, * posz;
   GfsFunction * velx, * vely, * velz;
hunk ./modules/particulatecommon.h 235
-  GfsFunction * np,   * mass, * vol;
+  GfsFunction * np,   * mass, * vol, * condition;
 };
 
 #define GFS_FEED_PARTICLE(obj)            GTS_OBJECT_CAST (obj,\
hunk ./modules/particulatecommon.h 247
 
 GfsEventClass * gfs_feed_particle_class  (void);
 
+typedef struct _GfsFeedParticle2 GfsFeedParticle2;
+
+struct _GfsFeedParticle2{
+  /*< private >*/
+  GfsEvent parent;
+  
+  /*< public >*/
+  GfsParticleList * plist;
+  GfsFunction * posx, * posy, * posz;
+  GfsFunction * velx, * vely, * velz;
+  GfsFunction * np,   * mass, * vol;
+};
+
+#define GFS_FEED_PARTICLE2(obj)            GTS_OBJECT_CAST (obj,\
+					         GfsFeedParticle2,\
+					         gfs_feed_particle2_class ())
+
+#define GFS_IS_FEED_PARTICLE2(obj)         (gts_object_is_from_class (obj,\
+					         gfs_feed_particle2_class ()))
+
+GfsEventClass * gfs_feed_particle2_class  (void);
+
+/* gfs_particle_bc: header */
+typedef struct _GfsBcParticle GfsBcParticle;
+struct _GfsBcParticle{
+  GfsParticleList * plist; 
+  GSList * boundary;
+};
 
hunk ./modules/particulatecommon.h 276
+static void gfs_particle_bc (GfsParticleList *plist);
+void distance_normalization (FttVector * pos1, GfsParticulate * p);
hunk ./src/particle.c 38
       (event, sim)) {
     GfsParticle * p = GFS_PARTICLE (event);
     FttVector pos = p->pos;
-    gfs_simulation_map (sim, &pos);
+    p->pos_old = p->pos;
     gfs_domain_advect_point (GFS_DOMAIN (sim), &pos, sim->advection_params.dt);
hunk ./src/particle.c 40
-    gfs_simulation_map_inverse (sim, &pos);
     p->pos = pos;
     return TRUE;
   }
hunk ./src/particle.c 77
   }
   p->pos.z = atof (fp->token->str);
   gts_file_next_token (fp);
+
+  gfs_simulation_map (gfs_object_simulation(*o), &p->pos);
 }
 
 static void gfs_particle_write (GtsObject * o, FILE * fp)
hunk ./src/particle.c 84
 {
   GfsParticle * p = GFS_PARTICLE(o);
+  gfs_simulation_map_inverse (gfs_object_simulation(o), &p->pos);
   fprintf (fp, " %d %g %g %g", p->id, p->pos.x, p->pos.y, p->pos.z);
hunk ./src/particle.c 86
+  gfs_simulation_map (gfs_object_simulation(o), &p->pos);
 }
 
 static void gfs_particle_class_init (GfsEventClass * klass)
hunk ./src/particle.h 36
 struct _GfsParticle {
   GfsEvent parent;
   FttVector pos;
+  FttVector pos_old;
   guint id;
 };
 
[particualte_alpha: calculating the maximum distance of interface from the centroid and diving by radius of equivalent sphere to get alpha
mohitiitroorkee@gmail.com**20130810124405
 Ignore-this: 806c5fc0e0b8148a3eff6b220473e42d
] hunk ./modules/particulatecommon.c 43
   return result;
 }
 
+static FttVector subs_fttvectors_abs (FttVector *a, FttVector *b)
+{
+  FttVector result;
+  FttComponent c;
+  for(c = 0; c< FTT_DIMENSION; c++)    
+    (&result.x)[c]  = abs((&a->x)[c] - (&b->x)[c]);  
+  return result;
+}
+
 /* Same as in source.c used here to obtained viscosity */
 static GfsSourceDiffusion * source_diffusion_viscosity (GfsVariable * v)
 {
hunk ./modules/particulatecommon.c 921
 typedef struct {
   GfsVariable * tag, * c, *t;
   Droplets * drops;
+  gdouble * alpha;
   GfsVariable **u;
   guint * sizes;
   guint n, min;
hunk ./modules/particulatecommon.c 962
   }  
 }
 
+static void droplet_conversion(FttCell * cell, DropletsPar *p)
+{
+  gint i = GFS_VALUE(cell, p->tag);
+  FttVector pos;
+  FttComponent c;
+  if (i>0)  {
+    gfs_vof_center(cell, p->c, &pos);
+    FttVector center;
+     for (c = 0; c < FTT_DIMENSION; c++) {
+      	(&center.x)[c] = (&p->drops[i].pos.x)[c]/p->sizes[i];
+	}
+    FttVector radius = subs_fttvectors_abs(&pos, &center);
+    double distance = (radius.x*radius.x + radius.y*radius.y + radius.z*radius.z)/((3./4.*M_PI)*pow(p->drops[i-1].volume,1./3.));
+    if (distance > p->alpha[i-1])
+      p->alpha[i-1] = distance;
+  }
+}
+
+static gboolean is_interfacial (FttCell * cell, gpointer data)
+{
+  GfsVariable * f = data;
+  return (GFS_VALUE (cell, f) > 0. && GFS_VALUE (cell, f) < 1.);
+}
+
 static gint particle_id(GfsParticleList * plist)
 {
   return ++plist->idlast;
hunk ./modules/particulatecommon.c 1029
 {
   GfsSimulation * sim = gfs_object_simulation (d); 
   guint i;
-  
   pars->sizes = g_malloc0 (pars->n*sizeof (guint));  
   pars->drops = g_malloc0 (pars->n*sizeof (Droplets));
hunk ./modules/particulatecommon.c 1031
-
+  pars->alpha = g_malloc0 (pars->n*sizeof (gdouble));
   FttComponent c;
   /* Initialize drops */
   for (i = 0; i < pars->n; i++){
hunk ./modules/particulatecommon.c 1037
     pars->drops[i].volume = 0.;
     pars->sizes[i] = 0;
+    pars->alpha[i] = 1.;
     for(c = 0; c < FTT_DIMENSION; c++) {
       (&(pars->drops[i].pos.x))[c] = 0.;
       (&(pars->drops[i].vel.x))[c] = 0.;
hunk ./modules/particulatecommon.c 1045
   }
   gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
 			    (FttCellTraverseFunc) compute_droplet_properties, pars);
-
+  gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+  				      (FttCellTraverseFunc) droplet_conversion , pars, is_interfacial, pars->c);
 #ifdef HAVE_MPI
   if (domain->pid >= 0) {
     guint * sizes = g_malloc0 (pars->n*sizeof (guint));
hunk ./modules/particulatecommon.c 1068
   }
   
   for (i = 0; i < pars->n; i++) {
-    if (pars->sizes[i] < pars->min){
+    if (pars->sizes[i] < pars->min && pars->alpha[i] < 2){
       GfsParticulate newpart; 
       for (c = 0; c < FTT_DIMENSION; c++) {
       	(&newpart.parent.pos.x)[c] = (&pars->drops[i].pos.x)[c]/pars->sizes[i];
hunk ./modules/particulatecommon.c 1088
 			    (FttCellTraverseFunc) reset_small_fraction, pars); 
   g_free (pars->drops);
   g_free (pars->sizes);
+  g_free (pars->alpha);
  
 }
 
hunk ./modules/particulatecommon.c 1094
 /* GfsDropletToParticle: object */
 
-typedef struct {                                                                                                        GfsVariable * v;
+typedef struct {                                                                                                       
+  GfsVariable * v;
   GfsFunction * fc;
 } compute_v_data;  
 
hunk ./modules/particulates.c 21
  */
 
 #include "particulatecommon.h"
+#include "output.h"
+#include "unstructured.h"
 
hunk ./modules/particulates.c 24
+/* GfsPdfParticle: header */
+
+typedef struct _GfsPdfParticle GfsPdfParticle;
+
+struct _GfsPdfParticle{
+  /*< private >*/
+  GfsOutput parent;
+  
+  /*< public >*/
+  gint level;
+  gchar * name;
+  gint nbins;
+  gdouble dbin;
+  gdouble rmin,rmax;
+  GfsVariable *c;  
+  GfsVariable *npcell,*meanpcell,*sdpcell;
+};
+
+#define GFS_PDF_PARTICLE(obj)            GTS_OBJECT_CAST (obj,\
+					         GfsPdfParticle,\
+					         gfs_pdf_particle_class ())
+
+#define GFS_IS_PDF_PARTICLE(obj)         (gts_object_is_from_class (obj,\
+					         gfs_pdf_particle_class ()))
+
+GfsOutputClass * gfs_pdf_particle_class  (void);
+
+typedef struct {
+  FttVector pos, vel;
+  gdouble volume;
+} Droplets;
+
+typedef struct {
+  GfsVariable * tag, * c;
+  Droplets * drops;
+  guint * sizes;
+  GfsVariable **u;
+  guint n;
+  gdouble rmin,rmax;
+  GfsPdfParticle *pdf;
+  GfsDomain *domain;
+} DropletsPar;
+
+static void compute_droplet_properties (FttCell * cell, DropletsPar * p)
+{
+  gint i = GFS_VALUE (cell, p->tag);
+  gdouble h = ftt_cell_size (cell), vol;
+  FttVector pos; 
+  ftt_cell_pos (cell, &pos);
+  GfsVariable ** u = p->u;
+
+  if (i > 0) {
+    p->sizes[i - 1]++;
+    vol = pow (h, FTT_DIMENSION);
+    p->drops[i-1].volume += vol*GFS_VALUE (cell, p->c);
+    FttComponent c;
+    for(c = 0; c < FTT_DIMENSION; c++){
+      (&(p->drops[i-1].pos.x))[c] +=  (&pos.x)[c];
+      (&(p->drops[i-1].vel.x))[c] += GFS_VALUE (cell,u[c]);
+    }
+  }  
+}
+
+static void reset_pdf (FttCell * cell, GfsPdfParticle * p)
+{
+  GFS_VALUE(cell,p->npcell) = 0;
+  GFS_VALUE(cell,p->meanpcell) = 0;
+  GFS_VALUE(cell,p->sdpcell) = 0;
+}
+
+static void write_pdf (FttCell * cell, DropletsPar * p)
+{
+  GfsPdfParticle *pdf = p->pdf;
+  GfsDomain *domain = p->domain;
+  FILE * fp = GFS_OUTPUT (pdf)->file->fp;
+  FttVector pos;
+  ftt_cell_pos(cell,&pos);  
+
+  fprintf(fp,"%lf %lf %lf\n",pos.x,pos.y,pos.z);
+  gdouble *binfill = g_malloc0((pdf->nbins)*sizeof (double));
+  for (int i = 0; i < p->n; i++){
+    FttCell * cell1 = gfs_domain_locate (domain, p->drops[i].pos, pdf->level, NULL);  
+    if(cell1==cell){
+      gdouble dia = 2.*pow(3./(4.*M_PI)*p->drops[i].volume,0.333333);
+      int k = (int)(dia/pdf->dbin);
+      if(k > pdf->nbins-1) k = pdf->nbins-1;
+      //     printf("%d %lf %lf\n",k,dia/pdf->dbin,dia,pdf->dbin);
+      binfill[k]++;
+    }   
+  }
+  for(int i=0; i<pdf->nbins;i++) fprintf(fp,"%3.14lf %lf\n", (pdf->dbin*i + p->rmin), binfill[i]);  
+  g_free(binfill);
+  /*To print the cumulants of the pdf*/
+ //      fprintf(fp,"%lf %lf %lf %d %lf\n",pos.x,pos.y,pos.z, (int) GFS_VALUE(cell,p->npcell), GFS_VALUE(cell,p->meanpcell)); 
+   
+
+}
+
+static gboolean gfs_pdf_particle_event (GfsEvent * event, GfsSimulation * sim)
+{ 
+  if ((* GFS_EVENT_CLASS (GTS_OBJECT_CLASS (gfs_pdf_particle_class ())->parent_class)->event)
+      (event, sim)) {  
+
+
+   GfsPdfParticle *pdf = GFS_PDF_PARTICLE(event);
+   GfsDomain *domain = GFS_DOMAIN(gfs_object_simulation(pdf));
+   FILE * fp = GFS_OUTPUT(event)->file->fp;
+   DropletsPar p;
+   p.u = gfs_domain_velocity (domain);
+   p.c = pdf->c;
+   p.tag = gfs_temporary_variable (domain);
+   p.pdf = pdf;
+
+   p.n = gfs_domain_tag_droplets (domain, p.c, p.tag);
+   p.domain = domain;
+   gdouble meandrop = 0.;
+   if (p.n > 0){
+     FttComponent c;
+     p.sizes = g_malloc0 (p.n*sizeof (guint));  
+     p.drops = g_malloc0 (p.n*sizeof (Droplets));
+
+     /* Initialize drops */
+     for (int i = 0; i < p.n; i++){
+       p.drops[i].volume = 0.;
+       p.sizes[i] = 0;
+       for(c = 0; c < FTT_DIMENSION; c++) {
+	 (&(p.drops[i].pos.x))[c] = 0.;
+	 (&(p.drops[i].vel.x))[c] = 0.;
+       }
+     }
+    
+     gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+			       (FttCellTraverseFunc) compute_droplet_properties, &p);
+     
+     /* Average Pos and Velocity drops */
+     p.rmin = 100.;
+     p.rmax = 0.;
+     for (int i = 0; i < p.n; i++){
+       p.rmin = MIN(p.rmin,p.drops[i].volume);
+       p.rmax = MAX(p.rmax,p.drops[i].volume);
+       meandrop += p.drops[i].volume;
+       for(c = 0; c < FTT_DIMENSION; c++) {
+	 (&(p.drops[i].pos.x))[c] /= p.sizes[i];
+	 (&(p.drops[i].vel.x))[c] /= p.sizes[i];
+       }
+     }
+   }
+   
+/*     gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1, */
+/* 			    (FttCellTraverseFunc) reset_pdf, pdf);  */
+  
+/*    for (int i = 1; i < p.n; i++){ */
+/*     FttCell * cell = gfs_domain_locate (domain, p.drops[i].pos, pdf->level, NULL);   */
+/*     GFS_VALUE(cell, pdf->npcell) = GFS_VALUE(cell, pdf->npcell) + 1;  */
+/*     gdouble dia = 2.*pow(p.drops[i].volume/M_PI,1./2.); */
+/* #if !FTT_2D */
+/*     dia = 2.*pow(3.0*(p.drops[i].volume)/4.0/M_PI, 1./3.); */
+/* #endif        */
+/*     GFS_VALUE(cell, pdf->meanpcell) = (GFS_VALUE(cell, pdf->meanpcell) */
+/* 				       *(GFS_VALUE(cell, pdf->npcell)-1) + dia)/(GFS_VALUE(cell, pdf->npcell));    */
+/*    } */
+
+   p.rmax = 2.*pow(3./(4.*M_PI)*p.rmax,0.33333);
+   p.rmin = 2.*pow(3./(4.*M_PI)*p.rmin,0.333333);
+   meandrop = 2.*pow(3./(4.*M_PI)*meandrop/p.n,0.333333);
+   pdf->dbin = (meandrop - p.rmin)/(pdf->nbins/2.);
+   if(pdf->dbin==0) pdf->dbin = 100000.;
+   gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, pdf->level,
+   		     (FttCellTraverseFunc) write_pdf, &p); 
+  
+   g_free (p.drops);
+   g_free (p.sizes);
+   return TRUE;
+  }
+  return FALSE;
+}
+
+
+static void gfs_pdf_particle_destroy (GtsObject * o)
+{
+
+ (* GTS_OBJECT_CLASS (gfs_pdf_particle_class ())->parent_class->destroy) (o); 
+}
+
+static void gfs_pdf_particle_read (GtsObject ** o, GtsFile * fp)
+{  
+  if (GTS_OBJECT_CLASS (gfs_pdf_particle_class ())->parent_class->read)
+    (* GTS_OBJECT_CLASS (gfs_pdf_particle_class ())->parent_class->read) (o, fp);
+  if (fp->type == GTS_ERROR)
+    return;
+
+  GfsPdfParticle *pdf = GFS_PDF_PARTICLE(*o);
+  GfsDomain *domain = GFS_DOMAIN(gfs_object_simulation(pdf));
+
+  if (fp->type != GTS_INT){
+    gts_file_error (fp, "expecting an init");
+    return;
+  }
+  else
+    pdf->level = atoi(fp->token->str);
+
+  gts_file_next_token(fp);
+
+  if (fp->type != GTS_INT){
+    gts_file_error (fp, "expecting an init: no. bins");
+    return;
+  }
+  else
+    pdf->nbins = atoi(fp->token->str);
+
+  gts_file_next_token(fp);
+
+  if ((pdf->c = gfs_variable_from_name (domain->variables, fp->token->str)) == NULL) {
+    gts_file_error (fp, "unknown variable `%s'", fp->token->str);
+    return;
+  }
+  gts_file_next_token (fp);
+
+  pdf->npcell = gfs_domain_get_or_add_variable (domain, "Npcell", 
+						  "Number of particles in cell");  
+  pdf->meanpcell = gfs_domain_get_or_add_variable (domain, "Meanpcell", 
+						   "Mean size of the particles");
+  pdf->sdpcell = gfs_domain_get_or_add_variable (domain, "Sdpcell", 
+						   "Standard deviation of particle size");
+
+}
+
+static void gfs_pdf_particle_write (GtsObject * o, FILE * fp)
+{
+  (* GTS_OBJECT_CLASS (gfs_pdf_particle_class ())->parent_class->write) (o, fp);
+
+  GfsPdfParticle *pdf = GFS_PDF_PARTICLE(o);
+
+  fprintf(fp," %d %d %s", pdf->level, pdf->nbins, pdf->c->name);
+}
+
+static void gfs_pdf_particle_init ( GfsPdfParticle * pdf)
+{
+  pdf->level = 0;
+}
+
+static void gfs_pdf_particle_class_init (GfsEventClass * klass)
+{
+  GFS_EVENT_CLASS (klass)->event    = gfs_pdf_particle_event;
+  GTS_OBJECT_CLASS (klass)->destroy = gfs_pdf_particle_destroy;
+  GTS_OBJECT_CLASS (klass)->read    = gfs_pdf_particle_read;
+  GTS_OBJECT_CLASS (klass)->write   = gfs_pdf_particle_write;  
+}
+
+GfsOutputClass * gfs_pdf_particle_class (void)
+{
+  static GfsOutputClass * klass = NULL;
+
+  if (klass == NULL) {
+    GtsObjectClassInfo gfs_pdf_particle_info = {
+      "GfsPdfParticle",
+      sizeof (GfsPdfParticle),
+      sizeof (GfsEventClass),
+      (GtsObjectClassInitFunc) gfs_pdf_particle_class_init,
+      (GtsObjectInitFunc) gfs_pdf_particle_init,
+      (GtsArgSetFunc) NULL,
+      (GtsArgGetFunc) NULL
+    };
+    klass = gts_object_class_new (GTS_OBJECT_CLASS (gfs_output_class ()),
+				  &gfs_pdf_particle_info);
+  }
+  return klass;
+}
 /* Initialize module */
 
 const gchar gfs_module_name[] = "particulates";
hunk ./modules/particulates.c 305
   gfs_force_drag_class ();
   gfs_force_buoy_class ();
   gfs_particle_force_class ();
+  gfs_source_particulate_class ();
 
   gfs_droplet_to_particle_class ();
hunk ./modules/particulates.c 308
+  gfs_particle_to_droplet_class ();
   gfs_feed_particle_class ();
hunk ./modules/particulates.c 310
-
+  // gfs_feed_particle2_class ();
   gfs_particulate_field_class ();
 
hunk ./modules/particulates.c 313
+  gfs_pdf_particle_class ();
   return NULL; 
 }
[sphericity_distribution
mohitiitroorkee@gmail.com**20130813113112
 Ignore-this: 8e6354a18637dc0107891cea3f7dcac1
] hunk ./modules/particulatecommon.c 949
   FttVector pos; 
   ftt_cell_pos (cell, &pos);
   GfsVariable ** u = p->u;
-
   if (i > 0) {
     p->sizes[i - 1]++;
     vol = pow (h, FTT_DIMENSION);
hunk ./modules/particulatecommon.c 969
   if (i>0)  {
     gfs_vof_center(cell, p->c, &pos);
     FttVector center;
-     for (c = 0; c < FTT_DIMENSION; c++) {
-      	(&center.x)[c] = (&p->drops[i].pos.x)[c]/p->sizes[i];
+         for (c = 0; c < FTT_DIMENSION; c++) {
+	   (&center.x)[c] = (&p->drops[i-1].pos.x)[c]/p->sizes[i-1];
 	}
hunk ./modules/particulatecommon.c 972
-    FttVector radius = subs_fttvectors_abs(&pos, &center);
-    double distance = (radius.x*radius.x + radius.y*radius.y + radius.z*radius.z)/((3./4.*M_PI)*pow(p->drops[i-1].volume,1./3.));
+    FttVector radius = subs_fttvectors(&pos, &center);
+    double distance = (pow((radius.x*radius.x + radius.y*radius.y + radius.z*radius.z),1./2.))/(pow((3./(4.*M_PI))*p->drops[i-1].volume,1./3.));
+    //printf("%lf \n",distance);
     if (distance > p->alpha[i-1])
       p->alpha[i-1] = distance;
   }
hunk ./modules/particulatecommon.c 1045
   }
   gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
 			    (FttCellTraverseFunc) compute_droplet_properties, pars);
-  gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
-  				      (FttCellTraverseFunc) droplet_conversion , pars, is_interfacial, pars->c);
+    gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+    				      (FttCellTraverseFunc) droplet_conversion , pars, is_interfacial, pars->c);
 #ifdef HAVE_MPI
   if (domain->pid >= 0) {
     guint * sizes = g_malloc0 (pars->n*sizeof (guint));
hunk ./modules/particulatecommon.c 1068
   }
   
   for (i = 0; i < pars->n; i++) {
-    if (pars->sizes[i] < pars->min && pars->alpha[i] < 2){
+    printf("Eccentricity of drop is %lf \n",pars->alpha[i]);
+    if (pars->sizes[i] < pars->min && pars->alpha[i] < 1.5){
       GfsParticulate newpart; 
       for (c = 0; c < FTT_DIMENSION; c++) {
       	(&newpart.parent.pos.x)[c] = (&pars->drops[i].pos.x)[c]/pars->sizes[i];
hunk ./modules/particulates.c 26
 
 /* GfsPdfParticle: header */
 
+static FttVector subs_fttvectors (FttVector *a, FttVector *b)
+{
+  FttVector result;
+  FttComponent c;
+  for(c = 0; c< FTT_DIMENSION; c++)    
+    (&result.x)[c]  = (&a->x)[c] - (&b->x)[c];  
+  return result;
+}
+
 typedef struct _GfsPdfParticle GfsPdfParticle;
 
 struct _GfsPdfParticle{
hunk ./modules/particulates.c 46
   gchar * name;
   gint nbins;
   gdouble dbin;
+  gdouble dabin;
   gdouble rmin,rmax;
hunk ./modules/particulates.c 48
+  gdouble amin,amax;
   GfsVariable *c;  
   GfsVariable *npcell,*meanpcell,*sdpcell;
 };
hunk ./modules/particulates.c 74
   GfsVariable **u;
   guint n;
   gdouble rmin,rmax;
+  gdouble amin,amax;
   GfsPdfParticle *pdf;
   GfsDomain *domain;
hunk ./modules/particulates.c 77
+  gdouble * alpha;
 } DropletsPar;
 
 static void compute_droplet_properties (FttCell * cell, DropletsPar * p)
hunk ./modules/particulates.c 100
   }  
 }
 
+static void droplet_conversion(FttCell * cell, DropletsPar *p)
+{
+  gint i = GFS_VALUE(cell, p->tag);
+  FttVector pos;
+  FttComponent c;
+  if (i>0)  {
+    gfs_vof_center(cell, p->c, &pos);
+    FttVector center;
+         for (c = 0; c < FTT_DIMENSION; c++) {
+	   (&center.x)[c] = (&p->drops[i-1].pos.x)[c]/p->sizes[i-1];
+	}
+    FttVector radius = subs_fttvectors(&pos, &center);
+    double distance = (pow((radius.x*radius.x + radius.y*radius.y + radius.z*radius.z),1./2.))/(pow((3./(4.*M_PI))*p->drops[i-1].volume,1./3.));
+    //printf("%lf \n",distance);
+    if (distance > p->alpha[i-1])
+      p->alpha[i-1] = distance;
+  }
+}
+
+static gboolean is_interfacial (FttCell * cell, gpointer data)
+{
+  GfsVariable * f = data;
+  return (GFS_VALUE (cell, f) > 0. && GFS_VALUE (cell, f) < 1.);
+}
+
 static void reset_pdf (FttCell * cell, GfsPdfParticle * p)
 {
   GFS_VALUE(cell,p->npcell) = 0;
hunk ./modules/particulates.c 142
 
   fprintf(fp,"%lf %lf %lf\n",pos.x,pos.y,pos.z);
   gdouble *binfill = g_malloc0((pdf->nbins)*sizeof (double));
+  //gdouble *abinfill = g_malloc0((pdf->nbins)*sizeof (double));
   for (int i = 0; i < p->n; i++){
     FttCell * cell1 = gfs_domain_locate (domain, p->drops[i].pos, pdf->level, NULL);  
     if(cell1==cell){
hunk ./modules/particulates.c 148
       gdouble dia = 2.*pow(3./(4.*M_PI)*p->drops[i].volume,0.333333);
       int k = (int)(dia/pdf->dbin);
+      int l = (int)(p->alpha[i]/pdf->dabin);
       if(k > pdf->nbins-1) k = pdf->nbins-1;
hunk ./modules/particulates.c 150
+      //if(l > pdf->nbins-1) l = pdf->nbins-1;
       //     printf("%d %lf %lf\n",k,dia/pdf->dbin,dia,pdf->dbin);
       binfill[k]++;
hunk ./modules/particulates.c 153
+      printf("i am here \n");
+      //abinfill[l]++;
     }   
   }
   for(int i=0; i<pdf->nbins;i++) fprintf(fp,"%3.14lf %lf\n", (pdf->dbin*i + p->rmin), binfill[i]);  
hunk ./modules/particulates.c 159
   g_free(binfill);
+  //g_free(abinfill);
   /*To print the cumulants of the pdf*/
  //      fprintf(fp,"%lf %lf %lf %d %lf\n",pos.x,pos.y,pos.z, (int) GFS_VALUE(cell,p->npcell), GFS_VALUE(cell,p->meanpcell)); 
    
hunk ./modules/particulates.c 184
    p.n = gfs_domain_tag_droplets (domain, p.c, p.tag);
    p.domain = domain;
    gdouble meandrop = 0.;
+   gdouble meanalpha = 0.;
    if (p.n > 0){
      FttComponent c;
      p.sizes = g_malloc0 (p.n*sizeof (guint));  
hunk ./modules/particulates.c 189
      p.drops = g_malloc0 (p.n*sizeof (Droplets));
-
+     //p.alpha = g_malloc0 (p.n*sizeof (double));
      /* Initialize drops */
      for (int i = 0; i < p.n; i++){
        p.drops[i].volume = 0.;
hunk ./modules/particulates.c 194
        p.sizes[i] = 0;
+       //p.alpha[i] = 1.;
        for(c = 0; c < FTT_DIMENSION; c++) {
 	 (&(p.drops[i].pos.x))[c] = 0.;
 	 (&(p.drops[i].vel.x))[c] = 0.;
hunk ./modules/particulates.c 203
     
      gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
 			       (FttCellTraverseFunc) compute_droplet_properties, &p);
+      gfs_domain_cell_traverse_condition (domain, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,
+    				      (FttCellTraverseFunc) droplet_conversion , &p, is_interfacial, &p.c);
      
      /* Average Pos and Velocity drops */
      p.rmin = 100.;
hunk ./modules/particulates.c 208
-     p.rmax = 0.;
+     p.rmax = 0.; 
+     p.amin = 100.;
+     p.amax = 0.;
+     
      for (int i = 0; i < p.n; i++){
        p.rmin = MIN(p.rmin,p.drops[i].volume);
        p.rmax = MAX(p.rmax,p.drops[i].volume);
hunk ./modules/particulates.c 215
+       //p.amin = MIN(p.amin, p.alpha[i]);
+       //p.amax = MAX(p.amax, p.alpha[i]);
+       //meanalpha += p.alpha[i];
        meandrop += p.drops[i].volume;
        for(c = 0; c < FTT_DIMENSION; c++) {
 	 (&(p.drops[i].pos.x))[c] /= p.sizes[i];
hunk ./modules/particulates.c 244
    p.rmin = 2.*pow(3./(4.*M_PI)*p.rmin,0.333333);
    meandrop = 2.*pow(3./(4.*M_PI)*meandrop/p.n,0.333333);
    pdf->dbin = (meandrop - p.rmin)/(pdf->nbins/2.);
+   //pdf->dabin = (p.amax - p.amin)/(pdf->nbins); 
    if(pdf->dbin==0) pdf->dbin = 100000.;
hunk ./modules/particulates.c 246
+   //if(pdf->dabin==0) pdf->dabin = 100000.;
    gfs_domain_cell_traverse (domain, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, pdf->level,
    		     (FttCellTraverseFunc) write_pdf, &p); 
   
hunk ./modules/particulates.c 252
    g_free (p.drops);
    g_free (p.sizes);
+   //g_free (p.alpha);
    return TRUE;
   }
   return FALSE;

Context:

[TAG 2013-05-28
Release**20130531065717] 
Patch bundle hash:
cef9e0a5bcff7d53d1ac911db2a8e3430921d4aa
